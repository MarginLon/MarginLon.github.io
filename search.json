[{"categories":null,"content":" Abstract H5 \u0026 CSS3  HTTP HyperText Transfer Protocol HTML  语义化 规范 扩展   !Entity CSS  At-rule CSS变量 文字 列表 链接 元素分类 边框 溢流 背景 轮廓 阴影   CSS3  浏览器引擎前缀 背景 边框 文字 动画\u0026过渡     CSS选择器  选择器  CSS3选择器     CSS预处理器  - stylus   CSS工程化模块化 布局  布局模型 布局   移动端响应式适配 Icon CSS工作原理 动画 CSS渲染原理和性能优化 面试相关  Abstract 1.浏览器加载HTML 2.HTML-\u003eDOM 3.浏览器获取HTML链接的大多数资源，包括CSS 4.解析CSS，选择器类型将不同规则分类为不同的“存储桶”（渲染树） 5.将渲染树放置在规则应用到其后应出现的结构中。 6.页面的视觉显示（绘画）   H5 \u0026 CSS3 HTTP HyperText Transfer Protocol  HTTP 状态码  200 ：成功。 400 ：客户端请求有语法错误，服务器端不能理解。 401 ：该请求可能未经过授权。 403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。 404 ：该资源没找到。 500 ：服务器端发生了一个不可预知的错误。 503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。   Web Storage  cookie  大小：4kb 带宽：访问消耗 安全风险   Web Storage  存储大小：5~10MB 不发送至服务器 更丰富的接口 localStorage,sessionStorage   localStorage  持久化的本地存储，不手动删除不会过期 存储：localStorage.setItem(key,value); 读取：localStorage.getItem(key); 删除：localStorage.removeItem(key); / localStorage.clear();      HTML 语义化  概念：对⽂本内容结构化（内容语义化），选择合乎语义的标签（代码语义化），便于开发者阅读，维护和写出更优雅的代码的同时，让浏览器的爬⾍和辅助技术更好的解析 优势：  利于SEO优化 在样式丢失的时候，仍可以⽐较好的呈现结构 更好地⽀持各种终端 利于团队开发和维护，提⾼效率    规范  div和p，尽量⽤p，因为p在默认情况下有上下间距，对兼容特殊终端有利。 需要强调的⽂本，可以使⽤ strong 或 em 标签。 使⽤表格时，标题⽤ caption，表头⽤ thead，主体部分⽤ tbody 包围，尾部⽤ tfoot 包围。表头 和⼀般单元格要区分开，表头⽤ th，单元格⽤ td。 表单域要⽤ fieldset 标签包起来，并⽤ legend 标签说明表单的⽤途（可理解为表单标题）。  1 2 3 4 5 6 7 8  \u003cform\u003e \u003cfieldset\u003e \u003clegend\u003ePersonalia:\u003c/legend\u003e \u003c!-- legend 可理解为表单标题 --\u003e Name: \u003cinput type=\"text\"\u003e\u003cbr\u003e Email: \u003cinput type=\"text\"\u003e\u003cbr\u003e Date of birth: \u003cinput type=\"text\"\u003e \u003c/fieldset\u003e \u003c/form\u003e    每个input标签对应的说明⽂本都需要使⽤label标签，并且通过为input设置id属性，在lable标签中 设置for=someld来让说明⽂本和相对应的input关联起来。或者直接在label中内嵌控件。  1 2 3 4 5  \u003clabel for=\"username\"\u003e请输⼊⽤户名: \u003c/label\u003e \u003cinput type=\"text\" id=\"username\" name=\"username\"\u003e \u003c!-- OR --\u003e \u003clabel\u003e请输⼊⽤户名\u003cinput type=\"text\" id=\"username\" name=\"usern ame\"\u003e\u003c/label\u003e    嵌套规范：  内联元素不能包含块元素 块元素不能放在\u003cp\u003e内 h1~h6,dt不能包含块元素   title, keywords, description精简全面 a标签设置title;外部链接设置rel; rel=“nofollow” 所有标题使用h1 br只用于文本换行 img设置alt  扩展  meta  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u003c!-- 编码 --\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003c!-- 关键词 --\u003e \u003cmeta name=\"keywords\" content=\"\" /\u003e \u003c!-- 描述 --\u003e \u003cmeta name=\"description\" content=\" \" /\u003e \u003c!-- 视口-移动设备 --\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale= 1\"\u003e \u003c!-- 优先使用IE新版本和Chrome --\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /\u003e \u003c!-- 刷新和重定向 --\u003e \u003cmeta http-equiv=\"refresh\" content=\"0;url=\" /\u003e \u003c!-- 禁⽌浏览器从本地计算机的缓存中访问⻚⾯内容 --\u003e \u003cmeta http-equiv=\"Pragma\" content=\"no-cache\"\u003e \u003c!-- 避免转码 --\u003e \u003cmeta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /\u003e \u003c!-- 启用WebApp全屏模式 --\u003e \u003cmeta name=\"apple-mobile-web-app-capable\" content=\"yes\" /\u003e    Entity    CSS At-rule  常规 ：@[KEYWORD] (RULE)  @charset @import @namespace   嵌套 : @[KEYWORD] { /* 嵌套语句 */ }  @document @font-face @keyframes @media @page @supports    CSS变量  全局/局部  1 2 3 4 5 6 7 8 9  /*全局变量*/ :root { --color: blue; } .box{color: var(--color)} /*局部变量*/ .box{ --color: red; color: var(--color); }    拼接  如果变量值是⼀个字符串，可以与其他字符串拼接； 如果变量值是数值，不能与数值单位直接连⽤，使用calc()函数； 如果变量值带有单位，就不能写成字符串;    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /*字符串拼接*/ .foo { --bar: 'hello'; --concat: var(--bar) ' world'; } /*变量为数值*/ .foo { --gap: 20; margintop: calc(var(--gap) * 1px); } /*带单位*/ .foo { --foo: 20px; font-size: var(--foo); }   文字 1 2 3 4 5 6 7 8 9 10 11 12  body { font-family:'Arial'; font-size:40px; color:red; font-weight:bold; font-style:italic; text-decoration:line-through|underline|overline; text-indent:2em; line-height:30px; letter-spacing:2em; text-align:center|left|right; }   列表 1 2 3 4  ul{ list-style-type:circle|disc|square|decimal|lower-alpha|upper-alpha; list-style-position:outside|inside; }   链接 1 2 3 4  a:link{} a:hover{} a:active{} a:visited{}   元素分类  块级元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u003c!--宽度继承父元素--\u003e \u003cdiv\u003e \u003cp\u003e\u003c/p\u003e \u003ch1\u003e ... \u003ch6\u003e \u003col\u003e \u003cul\u003e \u003ctable\u003e \u003caddress\u003e \u003cblockquote\u003e \u003cform\u003e\u003c/form\u003e \u003c/blockquote\u003e \u003c/address\u003e \u003c/table\u003e \u003c/ul\u003e \u003c/ol\u003e \u003c/h6\u003e \u003c/h1\u003e \u003c/div\u003e    行内元素  1 2 3 4 5 6 7  \u003c!--宽度为包含的内容的宽度，高度，行高，顶底边间距不可以设置--\u003e \u003ca\u003e \u003cspan\u003e \u003cbr /\u003e \u003ci\u003e \u003cem\u003e \u003cstrong\u003e \u003clabel\u003e\u003c/label\u003e\u003c/strong\u003e\u003c/em\u003e\u003c/i\u003e\u003c/span\u003e\u003c/a\u003e    行内块元素  1  \u003cimg /\u003e \u003cinput /\u003e   边框 1 2 3 4 5  div { border:2px solid|dashed|dotted red; border-radius:50%; }   溢流 1 2 3 4 5 6 7 8 9 10 11 12  p { } .one { overflow:auto; } .two { overflow:hidden; } .three { overflow:visible; }   背景 1 2 3  div { background-image: linear-gradient(to bottom, red, blue); }   轮廓 1 2 3  p{ outline:red dotted thick; }   阴影 1 2 3  div { box-shadow:inset 2px 2px 5px #000000; }    CSS3 浏览器引擎前缀  -moz- ：Firefox 等使用 Mozilla 引擎的浏览器。 -webkit- ：Safari 、 Chrome 等使用 Webkit 引擎的浏览器。 -o- ：Opera 浏览器早期。 -ms- ：IE 和 Edge 等 。  背景  background-size:length|percentage|cover|contain; background-origin:padding-box|border-box|content-box; background-clip:border-box|padding-box|content-box;.  边框  border-radius border-image:source(url) slice width outset repeat;  slice:图片边框向内偏移。 width:图片边框宽度。 outset:边框图像区域超出边框的量。 repeat:图像边框是否应该平铺（repeat）、铺满（round）或拉伸（stretch）。   box-shadow:水平阴影 垂直阴影 模糊阴影 阴影尺寸 阴影颜色 inset;  文字  RGBA text-shadow:水平阴影 垂直阴影 模糊阴影 阴影颜色; text-overflow:clip|ellipsis|string;  text-overflow一定要和overflow: hidden;、white-space: nowrap; 一起使用，不能单独用。   overflow-wrap:normal|break-word; word-break:normal|break-all|keep-all|;  动画\u0026过渡  渐变  线性  background: linear-gradient(to direction | angle, color-stop1, color-stop2...);   径向  background-image: radial-gradient(shape size at position,start-color,...,last-color);     过渡     transition-delay;``` + cubic-bezier(n,n,n,n):在 cubic-bezier 函数中定义自己的值，取值范围是 0 ~ 1。\n 2D\u00263D  transform: 将 2D 或 3D 转换应用到元素上去 transform-origin：可以改变被转换元素的位置 transform-style：规定被嵌套元素如何在 3D 空间中显示 perspective：规定 3D 元素的透视效果，与 perspective-origin 结合使用，可以改变 3D 元素的底部位置   动画  @keyframes     CSS选择器 选择器  基础选择器：标签选择器，类选择器，id 选择器，通配符选择器 组合选择器：标签指定式选择器(p.one)，后代选择器(p .one)，子代选择器(p\u003e.one)并集选择器 属性选择器  E[attr] E[attr=val] E[attr~=val]:其中一个等于\"val\" E[attr|=val]:其中之一以\"val\"开头   伪类选择器  :link :hover :active :visited   选择器规则:   级联：两个规则，后者胜出\n  特异性：内联\u003eid\u003e类\u003e元素\n  继承:inherit initial unset\n    CSS3选择器  选择器  E~F E+F E[attr^=“val”]:以val开头 E[attr$=“val”]:以val结尾 E[attr*=“val”]：包含val E:root 设置html E:nth-child(n) 第n个子元素 E:nth-last-child(n) E:nth-of-type() E:nth-last-of-type(n) E:last-child E:first-of-type E:last-of-type E:first-of-type E:only-child E:only-of-type E:empty E:target E:not(s) E:enabled \u0026 E:disabled E:checked   伪元素  :: ::after   1 2 3 4 5 6  \u003c!-- 清除浮动 --\u003e .clearfix::after{ content:''; display:block; clear:both; }          CSS预处理器  less sass  Variable  !global !default   mixins  @mixin @include   extend  @extend selector   nesting  \u0026:hover { … } 群组嵌套 \u003e + ~  nav { border: { style: solid; width: 1px; color: #ccc; } }    Interpolation  #{}   Function   stylus   CSS工程化模块化  布局 布局模型  Flow  块状元素在所处的包含元素内，自上而下按顺序垂直延伸，默认宽度100% 行内元素从左至右   Float  伪元素清除浮动    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  .clearfix:after { content: ''; /*设置内容为空*/ height: 0; /*高度为0*/ line-height: 0; /* 行高为0*/ display: block; /*将文本转为块级元素*/ visibility: hidden; /*将元素隐藏*/ clear: both; /*清除浮动*/ } .clearfix { zoom: 1; /*为了兼容IE*/ }    Layer  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  /* 1. 绝对定位 */ /* + 以浏览器左上角为基准 + 一个盒子包含在另一个盒子里，父不定位，子以浏览器左上角定位；父定位，子以父左上角定位 + 绝对定位不占空间 */ div { position:absolute; left: 100px; /*相对于浏览器向左偏移100像素*/ top: 80px; /*相对于浏览器向上偏移80像素*/ } /* 2. 相对定位 */ /* + 以元素自身的位置为基准 + 占空间位置 + 子绝对父相对 */ .box1 { width: 200px; height: 100px; position: relative; border: 1px dashed green; } .box2 { width: 100px; height: 50px; position: absolute; border: 1px dashed blue; top: 20px; left: 20px; } /* 3. 固定定位 */ /* + 类似于绝对定位，但固定定位相对于浏览器视口本身，而非\u003chtml\u003e或祖先元素*/ p { position: fixed; top: 200px; left: 100px; }   布局  Flex  容器属性  flex-direction  row|row-reverse|column|column-reverse   flex-warp  nowrap|wrap|warp-reverse   flex-flow  flex-direction和flex-warp的简写   justify-context  flex-start|flex-end|center|space-between|space-around   align-items  flex-start|flex-end|center|baseline|stretch   align-content  flex-start|flex-end|center|space-between|space-around     子元素属性  flex  flex-grow || flex-shrink || flex-basis;   align-self        移动端响应式适配  Icon  CSS工作原理  动画  CSS渲染原理和性能优化  面试相关  选择器:  css3新增选择器 新增伪类 优先级  选择器：  E~F E+F E[attr^=“val”]:以val开头 E[attr$=“val”]:以val结尾 E[attr*=“val”]：包含val   伪类：-child -of-type 选择器规则:   层叠：两个规则，后者胜出\n  优先级：!important\u003e内联\u003eid\u003e类\u003e元素\u003e*\u003e继承\u003e默认\n  继承:inherited:字体 文本 可见性 列表 声音 initial unset\n     伪类伪元素区别  伪类操作dom树中已有的元素，伪元素创建dom树外的元素。 语法:和::。 可以使用多个伪类，但同时只能使用1个伪元素。 伪类弥补常规选择器的不足，便于获取用户操作等额外信息，伪元素创建了一个有内容的虚拟容器。   属性继承  inherited:字体 文本 可见性 列表 声音   浏览器解析选择器  1  :not() \u003c!-- 权重：0，()内权重取决于内容 --\u003e        ","description":"","tags":null,"title":"CSS Summary","uri":"/web/css_summary/"},{"categories":null,"content":" 1. Basic 2. Other  1. Basic  Node.js 是一个开源与跨平台的 JavaScript 运行时环境。 Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。  2. Other ","description":"","tags":null,"title":"NodeJS Summary","uri":"/web/node/"},{"categories":null,"content":" 1. 简介 2. 基础知识整理  2.1 安装 2.2 v-指令 2.3 钩子   3. 面试题整理    1. 简介 整理之前学习的有关Vue的内容 供日后参考 若有补充也接在此处.  2. 基础知识整理 2.1 安装 1  \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e     npm install -g @vue/cli npm run serve –\n2.2 v-指令  v-model 双向 v-html v-text v-clock 配合CSS解决小胡子 v-pre v-for v-if v-show v-bind 处理行内属性，对class和style加强 v-on 处理事件  –\n2.3 钩子 3. 面试题整理 ","description":"","tags":null,"title":"Vue 整理","uri":"/web/vue/"},{"categories":null,"content":" 1. Abstract 2. Basic Item  2.1. {数据类型及转换}  2.1.1. {数据类型}  2.1.1.1. 原始值 2.1.1.2. 对象类型   2.1.2. {类型检测\u0026转换}  2.1.2.1. typeof/instanceof/.constructor/toString.call/Array.isArray([value]) 2.1.2.2. 其他=\u003eNumber 2.1.2.3. 其他=\u003eString 2.1.2.4. 其他=\u003e布尔 2.1.2.5. ==的规则 2.1.2.6. 对象=\u003e字符串/数字 2.1.2.7. 其他     2.2. {堆栈内存及执行代码的步骤} 2.3. {函数的底层执行机制} 2.4. {闭包机制}  2.4.1. 闭包应用之循环事件绑定的N种解决办法   2.5. {浏览器垃圾回收处理} 2.6. {let\u0026const\u0026var} 2.7. {this}  2.7.1. 事件绑定 2.7.2. 函数执行 [普通/成员访问/匿名函数/回调函数] 2.7.3. 构造函数 2.7.4. 箭头函数 [generator] 2.7.5. call/apply/bind强制修改this指向   2.8. {变量提升\u0026块级作用域} 2.9. {JS高阶技巧}  2.9.1. 单例设计模式 2.9.2. 惰性函数 2.9.3. 柯里化 2.9.4. compose   2.10. {防抖\u0026节流} 2.11. {面向对象编程} 2.12. {原型\u0026原型链} 2.13. {DOM} 2.14. {浏览器模型}   3. Others  3.1. {\u0026\u0026 ||}     1. Abstract  2. Basic Item 2.1. {数据类型及转换}  2.1.1. {数据类型}  2.1.1.1. 原始值   Undefined Null Boolean Number String Symbol  1.对象的唯一属性   1 2 3 4 5 6 7 8 9 10  let key = Symbol(); let obj = { [key]:100 }; console.log(obj[key]); let arr = Object.getOwnPropertySymbols(obj); arr.forEach(item=\u003e{ console.log(obj[item]); });      2.宏观管理标识：标志唯一性(vuex/redux) 3.底层原理  Symbol.hasInstance Symbol.iterator Symbol.toPrimitive Symbol.toStringTag …     Bigint   2.1.1.2. 对象类型   标准普通对象 object 标准特殊对象 Array/RegExp/Date/Error/Math/ArrayBuffer/DataView/Set/Map… 非标准特殊对象 Number/String/Boolean/Symbol/BigInt/… 基于构造函数[Object]创造出来的原始值对象类型   1 2 3  new Symbol() // TypeError new BigInt() // TypeError: Not a constructor Object(Symbol()) // pass      可调用对象 [实现了call方法] function  普通 构造[内置，自定义] 生成器 箭头 基于ES6快速为对象属性赋值函数的模式（QF）     2.1.2. {类型检测\u0026转换}  2.1.2.1. typeof/instanceof/.constructor/toString.call/Array.isArray([value])   typeof 运算符  返回字符串 null -\u003e ‘object’ 实现CALL的对象[函数、箭头函数、生成器函数、构造函数] -\u003e ‘function’ 未实现CALL的对象 -\u003e ‘object’ 未声明的变量 -\u003e ‘undefined’   [example] instanceof [class] 实例是否属于类 [example].constructor===[class] 获取构造函数 Object.prototype.toString.call([val])   2.1.2.2. 其他=\u003eNumber   Number([val])  隐式转换的调用方法（如isNaN()） 出现非有效数字字符即为NaN，空串为0 Symbol-\u003e报错   parseInt/parseFloat([val],[radix])  [val] 必须是一个字符串，否则隐式转换 [radix] 不设置或为0，按照10处理，若字符串'0x’开头，按照16处理 处理过程：在[val]中找到所有符合[radix]进制的内容，直到遇到不符合的字符，把找到的内容按照[radix]进制转换为10进制 [radix]范围：2~36,包括0,否则NaN   隐式转换  inNaN() 数学运算(特殊：\"+“的字符串拼接) “==”     2.1.2.3. 其他=\u003eString  - 规则： - 原始值引号包含 - toString() [排除Object.prototype.toString] - 普通对象{} = 'object Object' - String([val]) - 隐式转换 - \"+\" : 一边出现字符串，则拼接 - 基于alert/confirm/prompt/document.write等方式输出  2.1.2.4. 其他=\u003e布尔   规则:  只有\"0, NaN, Null, Undefined, 空字符串\"为False   ! !! Boolean([val]) A||B A\u0026\u0026B 隐式转换  循环或条件判断的结果     2.1.2.5. ==的规则   类型相同  {}=={} :false 比较堆内存地址 []==[] :false NaN==NaN :false Object.is(NaN, NaN) :true   类型不同  null==undefined :true === :false null/undefined与其他类型不相等 字符串==对象 对象=\u003e字符串 两边类型不一致，先转换为数字再比较     2.1.2.6. 对象=\u003e字符串/数字   检测Symbol.toPrimitive，获得原始值 第一步没有，valueOf获取原始值 第二步没有，调用toString，字符串 第三步后，若有需要，基于Number()，数字   2.1.2.7. 其他   “+”  {} + 0 左边{}视为代码块 // +0 =\u003e 0 ({} + 0) // “[object Object]0” 0 + {} // “0[object Object]”   模板字符串实现的是字符串拼接，对象转换为字符串，其余数学运算，对象=\u003e数字    2.2. {堆栈内存及执行代码的步骤}  浏览器运行JS代码，提供了栈内存(Stack)以运行代码  栈内存是计算机内存分配的 执行环境栈 EC stack (execution context stack)  EC(G) 全局执行上下文，全局代码执行  VO(G) 全局变量对象[存储全局上下文中声明的变量] GO(global object) 全局对象 [window]   EC(X) 某函数的执行上下文   等号赋值  创建值\n原始值类型的值，储存在栈内，对象数据类型单独开辟堆(Heap)内存 声明变量\n把声明的变量存储到当前上下文的变量对象中，如EC(G) 赋值\n指针的指向   堆内存  赋予一个16进制地址，对象中的键值依次存储，内存地址放在栈中供变量引用。       2.3. {函数的底层执行机制}  正常的函数创建 function fn(y){...} 匿名函数之函数表达式 var fn = function(y){...}; 创建步骤：  创建一个函数(值/对象)  创建一个堆内存 声明函数作用域scope(即哪个上下文) 存储代码(字符串) 16进制地址存入栈中以供引用   声明一个变量fn (函数名也是变量名) 关联   执行步骤  形成一个全新的私有context =\u003e EC(FN1) AO(FN1) 进栈 （AO:ActiveObject 变量对象） 初始化作用域链[Scope-chain]  \u003c当前自己的私有context，函数的作用域\u003e =\u003e 链的右侧是当前context的“上级”context   初始化this 初始化arguments 形参赋值：当前上下文声明一个形参变量，并传递实参值，非严格模式建立映射机制：集合中的每一项和对应的形参变量绑定（只在代码执行之前）。 变量提升 代码执行  变量：私有只操作自己，和外界无关；如果不是自己私有，则基于chain向context查找，是否为上级私有，如果不是，继续向上查找，直到EC(G)，即作用域链查找机制   出栈 or 不出栈     2.4. {闭包机制}  EC(FN)：  开辟的某个堆内存，被当前EC(FN)外的变量占用，此时当前context即EC(FN)不能被出栈释放 闭包：(大函数执行返回小函数只是其中一种形式)  函数执行产生一个私有context，保护内部私有变量不受污染。[保护] 有可能形成不被释放的context，私有变量和一些值被保存，可供下级context中调取使用。[保存] 闭包特点  保护：保护私有context的私有变量和外界互不影响 保存：context的私有变量和值保存起来 弊端：栈内存太大，影响性能，需合理利用        2.4.1. 闭包应用之循环事件绑定的N种解决办法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  var buttons = document.querySelectorAll('button'); for (var i = 0; i \u003c buttons.length; i++) { // i=0 buttons[0] 第一个按钮  // i=1 buttons[1] 第二个按钮  // ....  // 每一轮循环 i 变量的值 和 需要获取对应某个按钮的索引是一样的 buttons[i]  buttons[i].onclick = function(){ console.log('获取当前按钮索引:${i}'); //不能实现  }; } //方案1.1：基于“闭包”  // [每一轮循环都产生一个闭包，存储对应索引；  // 点击事件触发，执行对应函数，让其上级context闭包]  var buttons = document.querySelectorAll('button'); for (var i = 0; i \u003c buttons.length; i++) { // 每一轮循环形成一个闭包，存储私有变量i的值  // + 自执行函数执行，产生EC(A) 私有形参i=0/1/2  // + EC（A）中有个小函数,让全局buttons中的某一项占用创建的函数  (function(i) { buttons[i].onclick = function(){ console.log('获取当前按钮索引:${i}'); }; })(i); } //方案1.2：  var buttons = document.querySelectorAll('button'); for (var i = 0; i \u003c buttons.length; i++) i{ buttons[i].onclick = function(i){ return function () { console.log('获取当前按钮索引:${i}'); }; })(i); } //方案1.2注解  var obj = { //返回值赋值给fn  fn: (function(){ console.log('大函数'); return function(){ console.log('小函数'); } })() }; obj.fn();//执行返回的小函数  //方案1.3 基于let也是闭包  let buttons = document.querySelectorAll('button'); for (let i = 0; i \u003c buttons.length; i++) i{ buttons[i].onclick = function(){ console.log('获取当前按钮索引:${i}'); }; } //方案2 自定义属性  var buttons = document.querySelectorAll('button'); for (var i = 0; i \u003c buttons.length; i++) i{ // 每一轮循环给当前button设置自定义属性存索引  buttons[i].myIndex = i; buttons[i].onclick = function(){ // this -\u003e 当前点击的按钮  console.log('获取当前按钮索引:${this.myIndex}'); }; } //方案3 事件委托 html \u003cbutton index='i'\u003e\u003c/button\u003e;  // 无论点击body中的谁，都会触发body的点击事件  // ev.target事件源：具体点击的是谁  document.body.onclick = function(ev) { var target = ev.target targetTag = target.tagName; if(targetTag===\"BUTTON\"){ var index = target.getAttribute('index'); console.log('获取当前按钮索引:${this.myIndex}'); } };    2.5. {浏览器垃圾回收处理}  GC：浏览器的垃圾回收机制（内存释放）  栈内存：  加载页面，形成全局context，只有页面关闭后，全局context释放 函数执行私有context，进栈执行；函数中代码执行完成，大部分情况，出栈释放。  特殊：如果当前context的某些内容（一般是一个堆），被context以外内容占用，则不能出栈释放。     堆内存  （谷歌）：引用标记  浏览器在空闲或指定时间，查看所有堆内存，把没有被任何东西占用的堆内存释放。   （IE低版本）：引用计数  创建了堆内存，被占用一次，则浏览器计数+1，取消占用计数-1，计数=0释放内存； =\u003e 某些情况导致计数混乱，出现“内存泄漏”     释放内存：  x=null =\u003e 手动取消占用       2.6. {let\u0026const\u0026var}  传统声明变量：var function ES6：let const import() let VS const  let 变量储值可改 const 赋值不能再与其他赋值关联   let VS var  var 存在变量提升 let 不存在变量提升  变量提升：代码执行前“var/function”提前声明或定义  var 只声明 function 声明+定义 EC(G):if 无论条件是否成立，都变量提升，新浏览器function只声明不定义。     全局context var相当于给GO增一个属性，一改随改；let和GO没有关系。 let不允许同context重复声明（不管先前何种方式声明，都不能let声明,词法解析阶段），var无所谓。 var  var：方法内局部，方法外全局 不加var：全局    暂时性死区（基于typeof检测一个未被声明的变量，不会报错，结果是’undefined'）  只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。    1 2  console.log(typeof n);//undefined let n = 12;//使上一句报错      let产生块级私有context  context \u0026 作用域  全局context 函数执行的私有context 块级作用域（私有context）  对象 function的大括号 判断，循环和代码块的大括号  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  debugger;//开启断点调试,控制台基于F10/F11 逐过程/逐语句 控制执行  //代码块不会对n产生限制，n使全局context  { var n = 12; console.log(n); let m = 13; } console.log(n); console.log(m);// m is not defined  let i = 0;//不产生块级context  for (; i\u003c 5;i++) { console.log(i); } console.log(i);//5            2.7. {this}  全局context: this -\u003e window 块级context: this -\u003e 继承上级context(包括箭头函数)  2.7.1. 事件绑定  DOM0: xxx.onxxx = function(){} DOM2:  xxx.addEventListener('xxx',function(){}) xxx.attachEvent('onxxx',function(){})   给当前元素的某个事件行为绑定方法，当事件触发、方法执行，方法中的this是当前元素本身 特殊性：attachEvent -\u003e window  1 2 3  document.body.onclick = function () { console.log(this);//body };   2.7.2. 函数执行 [普通/成员访问/匿名函数/回调函数]  正常的普通函数执行：函数执行前是否有点，没有点，this即window（严格模式下undefined）；有点，谁点this谁 匿名函数（自执行函数/回调函数）如果没有特殊处理，则this一般都是window/undefined  函数表达式：等同于普通函数或事件绑定 自执行函数 回调函数：一般是window/undefined，如果另外函数执行中特殊处理，特殊为主。 括号表达式：小括号中包含\"多项”，取最后一项，但this受到影响（一般是window/undefined）    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  function fn(){ console.log(this); } let obj = { name: 'Margin', fn // fn: fn }; fn(); //this-\u003ewindow obj.fn();// this -\u003e obj (obj.fn)(); //this -\u003e obj (10, obj.fn)(); // this -\u003e window/undefined  // 函数表达式 var fn = function () { console.log(this); }; fn(); // 自执行函数 (function(x){ console.log(this); // this -\u003e window/undefined  })(10); // 回调函数：把一个函数A作为实参，传递给另外一个执行的函数B [B执行中把A执行] function fn(callback) { //callback -\u003e 匿名函数  //callback(); -\u003e window  callback.call(obj); // this -\u003e obj } fn(function(){ console.log(this); }); // let arr = [10,20,30]; arr.forEach(function(item,index){ console.log(this); // obj 触发回调函数执行的时候,  // forEach内部把回调函数的this改为传递的第二个参数值obj },obj); // setTimeout(function(){ console.log(this); //window },1000); setTimeout(function(x){ console.log(this, x); //window 10 },1000, 10);   2.7.3. 构造函数  初始this，把this指向当前的实例对象。  2.7.4. 箭头函数 [generator] 2.7.5. call/apply/bind强制修改this指向  2.8. {变量提升\u0026块级作用域}  变量提升：在当前context，JS代码自上而下执行之前，浏览器提前处理（词法解析的一个环节）  var/function 提前声明/定义 基于var/function 全局context 声明的变量映射到GO(window)一份，并随动。 if 无论条件是否成立，都变量提升（条件中带function在新浏览器只提前声明，不提前赋值）  1 2 3 4 5  var func = function AAA() { // 函数表达式匿名函数“具名化”，不能外部访问  // 函数内部私有context会把名字作为context的变量  // AAA(); 递归调用 而非arguments.callee }      块级作用域  原文章 块级作用域内默认变量  不带var，let，const，只有执行过定义的变量的代码后才可以访问，给window赋值属性，之前会报错 块内默认变量依旧是全局变量 没执行之前不可以访问   块级作用域函数声明  块内函数声明会提升到块顶部，也会在全局作用域用var声明一个同名的undefined变量 块外的全局同名变量的赋值时机是执行完块内函数声明语句 块内的函数声明每次执行的时候都会给全局那个同名的变量赋值一次，并且，只有执行那个定义函数声明的代码才会触发赋值，你写的函数声明就相当于setter,每执行一次就给外部的那个同名的变量赋值一次 如果块内同时有同名的函数声明和默认的变量声明，那给默认的变量赋值时其实相当于赋值给那个同名的函数，因为查找块内的作用域链时找到了,就不会往全局声明了。       2.9. {JS高阶技巧}  模块化编程  单例 AMD require.js CMD sea.js [CommonJS] CommonJS node.js ES6Module    2.9.1. 单例设计模式  对象：描述同一个事物的属性和方法，可防止全局污染  Object实例 “命名空间” window.xxx = xxx 闭包+单例 [早期模块化]    2.9.2. 惰性函数  函数重构[闭包]  1 2 3 4 5 6 7 8 9 10 11 12 13 14  function get_css(element,attr){ if ('getComputedStyle' in window) { get_css = function (element, attr) { return window.getComputedStyle(element)[attr]; }; } else { get_css = function (element, attr) { return element.currentStyle[attr]; }; } return get_css(element, attr); } ```     2.9.3. 柯里化  （预先处理）形成一个闭包，存储信息，供下级context调用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  let res = fn(1,2)(3); console.log(res);//=\u003e6 1+2+3  //ToDo function fn() { let outerArgs = Array.from(arguments); return function annoymous(){ let innerArgs = Array.from(arguments); let params = outerArgs.concat(innerArgs); return params.reduce(function(result, item){ return result + item; }); }; } // ES6 ToDo  //数组 reduce // + arr.reduce([function]) let arr = [10, 20, 30, 40]; let result = arr.reduce(function (result, item, index){ console.log(result,item,index); return result + item; }); // 重构 reduce function reduce(arr, callback, initValue) { let result = initValue, i = 0; if(typeof result==\"undefined\"){ result = arr[0]; i = 1; } } let arr = [10, 20, 30, 40]; let result = reduce(arr, function(result, item, index){ return result + item; }); console.log(result);   2.9.4. compose  f(g(h(x))) =\u003e compose(f,g,h)(x)  1 2 3 4 5 6 7 8 9 10  const compose = (...funcs) =\u003e { return x =\u003e { return funcs.reduceRight((result, item) =\u003e{ //result-\u003ex item-\u003eadd1  //result-\u003eadd1(x) item-\u003eadd1  return item(result); }, x); }; };    2.10. {防抖\u0026节流}  自己规定频繁触发的条件 防抖：只识别一次 –点击事件 节流：降低触发频率，能识别‘多次’ –键盘 滚动条  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /* debounce:函数防抖 @params func [funcion,required] : 最后要执行的函数 wait [number] 触发的频率时间 immediate [boolean] 设置是否开始边界触发 @return func执行的返回结果 */ function debounce (func, wait, immediate) { if(typeof func!==\"function\") throw new TypeError('func must be an function'); if(typeof wait ===\"boolean\") { immediate = wait; wait = 300; } if(typeof wait !==\"number\") wait =300; if(typeof immediate !==\"boolean\") immediate = false; var timer = null; return function proxy(...params){ //基于逻辑处理 让fn只执行一次  var runNow = !timer \u0026\u0026 immediate; if(timer) {clearTimeout(timer);} timer = setTimeout(function(){ if(timer) { clearTimeout(timer); timer = null; }; !immediate ?func(...params): null; }, wait); runNow?func(...params): null; }; } function fn(){ console.log('OK'); } box.onclick = debounce(fn,300,true); /* throttle:函数节流 @params func [funcion,required] : 最后要执行的函数 wait [number] 触发的频率时间 @return func执行的返回结果 */ function throttle(func, wait) { if(typeof func!==\"function\") throw new TypeError('func must be an function'); if(typeof wait !==\"number\") wait =300; var timer =null, previous =0, result; return function proxy(){ var now = +new Date(), remaining = wait - (now - previous), self = this, params = [].slice.call(arguments); if(remaining\u003c=0){ if(timer) { clearTimeout(timer); timer = null; } //立即执行  result = func.apply(self, params); previous = +new Date(); } else if(!timer) { // 没有达到间隔时间，之前没有设置过定时器，此时设置定时器，等待remaining后执行一次  timer =setTimeout(function(){ if(timer) { clearTimeout(timer); timer = null; } result = func.apply(self, params); previous = +new Date(); },remaining) } return result; }; } function fn(){ console.log('OK'); } box.onclick = throttle(fn,500);    2.11. {面向对象编程}  对象，类，实例：  对象：泛指 类：细分“对象”，大类和小类  封装，继承，多态  封装：功能的代码封装，低耦合高内聚 继承：子承父 多态：函数重载（名字相同，传参的个数或类型不同，JS中不存在），重写（子写父的新方法）     实例：某个类中具体事物  独有特征 共有特征     JS  内置类 自定义类（类都是“函数数据类型”）  函数执行的时候基于new执行即可“构造函数执行”  构造函数 VS 普通函数  创建context后，浏览器默认创建一个对象实例，把当前Fn函数当作类（”构造函数“） 初始this，把this指向当前的实例对象。 执行完，return时  没有return/return 基本数据类型值，浏览器默认把创建的实例对象返回 return 引用类型，返回自己的返回值。       Fn VS Fn()：  Fn代表函数本身（堆内存），Fn()函数执行，获取返回值。   new Fn VS new Fn()：  执行，第一个不传递实参，第二个传递实参。 优先级 19 VS 20   JS创建值（实例）两种方案:  字面量 构造函数new 对于对象和函数类型，无区别；对于原始值，字面量返回原始值类型，构造函数方式返回对象类型，但都是所属类的实例。 Symbol和BigInt 不允许new Object()   检测一个属性是否为当前对象的成员  属性名 in 对象：无论公私有，有就是true 对象.hasOwnProperty(属性名)：只有私有true   检测公有属性 1 2 3 4  function hasPubProperty(obj,attr){ //弊端：既私有又公有  return (attr in obj) \u0026\u0026 !obj.hasOwnProperty(attr); }    验证实例属于类 instanceof  1 instanceof Number // =\u003e false   基于\"for..in\"循环遍历  优先遍历数字属性 不会遍历到Symbol 会把自己扩展到“类原型”上的公共属性方法也遍历 [可枚举的] if(!obj.hasOwnProperty(key)) break;//遍历到公共属性，停止遍历 Object.keys(obj):非Symbol私有属性 [数组] Object.getOwnPropertyNames(obj): 同上 Object.getOwnPropertySymbols(obj):Symbol私有属性 [数组]  1 2 3 4  let keys = [...Object.keys(obj),...Object.getOwnPropertySymbols(obj)]; keys.forEach(key=\u003e { console.log(`属性名:$(),属性值:$()`);. });          2.12. {原型\u0026原型链}  函数数据类型内置prototype属性，属性值是一个对象(除Function.prototype是函数)，对象中存储属性和方法是供当前类所属实例调用的公共属性和方法  箭头函数\u0026QF函数没有prototype 原型对象上有一个内置的属性 constructor（构造器），属性值是当前函数本身   对象数据类型都具备：__proto__，属性值是当前实例所属类的原型prototype  Object.protptype的__proto__值是null，Object是所有对象的“基类”   原型链查找机制  f1.say  先找私有属性 没有，基于__proto__找所属类原型的公共属性方法 没有，基于原型对象的__proto__查找，直到Object.prototype   f1.__proto__.say  跳过私有的，找所属类原型的公有属性方法 Fn.prototype.say       2.13. {DOM}  基本类型  Document DocumentType:doctype标签 Element:H5标签 Attr:元素的属性 Text:标签内文本 Comment:注释 DocumentFragment:文档片段   获取方法  document.getElementById():基于元素ID [context].getElementByTagName():基于标签名,获取集合 [context].getElementByClassName():基于类名，获取集合 document.getElementByName():基于NAME属性值，一般只用于表单（IE只认表单的NAME） document.head/document.body/document.documentElement [context].querySelector([selector]) [context].querySelectorAll([selector])   关系属性  类型  Node NodeList(ByTagName/ByClassName/querySelectorAll)   nodeType:元素1/属性2/文本3/注释8/文档9 nodeName: nodeValue: childNodes:获得所有子节点 children:获得所有元素子节点 firstChild/lastChild: firstElementChild/lastElementChild: previousSibling/nextSibing: previousElementSibling/nextElementSibling:   增删改  createElement createTextNode appendChild insertBefore cloneNode: true|false removeChild setAttribute     2.14. {浏览器模型}  3. Others 3.1. {\u0026\u0026 ||} - A \u0026\u0026 B * 如果第一个操作数是对象，则返回第二个数 * 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象。 * 如果两个操作数都是对象，则返回第二个数操作数。 * 如果有一个操作数是null，则返回null。 * 如果有一个操作数是NaN，则返回NaN。 * 如果第一个操作数是undefined，则返回undefined。 * 对于逻辑与，如果第一个操作数是false，无论第二个操作数是什么，结果都不可能再是true。 - A || B * 如果第一个操作数是对象，则返第一个操作数 * 如果第一个操作数的求值结果为false，则返回第二个操作数 * 如果两个操作数都是对象，则返回第一个操作数 * 如果两个操作数是null，则返回null * 如果两个操作数是NaN，则返回NaN * 如果两个操作数是undefined，则返回undefined  ","description":"","tags":null,"title":"JavaScript Summary","uri":"/web/javascriptsummary/"},{"categories":null,"content":"VS Code自定义快捷模块  1 2 3 4 5 6 7 8 9 10  //1.\u003cctrl\u003e+\u003cshift\u003e+\u003cp\u003e //2. snippets //3. 新建 /*4. args: prefix：使用代码段的快捷入口 body：需要设置的代码放在这里,字符串间换行的话使用\\r\\n换行符隔开.如果值里包含特殊字符需要进行转义,多行代码以\",\"分隔(在引号后面写逗号) $0：定义最终光标位置 $1：定义第一次光标位置，按tab键可进行快速切换, 还可以有 $2, $3, $4, $5 ... description：代码段描述,在使用智能感知时的描述 * /   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 自定义(vue页面结构) { \"vue\": { \"prefix\": \"vue-tem\", // 设置的快捷入口 \"body\": [ // 模块内容 \"\u003c!-- $1 --\u003e\", // 光标 \"\u003ctemplate\u003e\", \" \u003cdiv\u003e\", \" $2\", \" \u003c/div\u003e\", \"\u003c/template\u003e\", \"\", \"\u003cscript\u003e\", \" export default {\", \" name: '',\", \" components: {\", \" \", \" },\", \" props: {\", \" \", \" },\", \" data() {\", \" return {\", \" \", \" }\", \" },\", \" computed: {\", \" \", \" },\", \" created() {\", \" \", \" },\", \" methods: {\", \" \", \" },\", \" watch: {\", \" \", \" },\", \" }\", \"\u003c/script\u003e\", \"\", \"\u003cstyle scoped lang=''\u003e\", \" \", \"\u003c/style\u003e\" ], \"description\": \"Vue templet\" // 说明 } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  { \"h5 sample\":{ \"prefix\": \"MYH5\", \"body\": [ \"\u003c!DOCTYPE html\u003e\", \"\u003chtml\u003e\", \"\u003chead\u003e\", \"\\t\u003cmeta charset=\\\"UTF-8\\\"\u003e\", \"\\t\u003cmeta name=\\\"keywords\\\" content=\\\"\\\"\u003e\", \"\\t\u003cmeta name=\\\"description\\\" content=\\\"\\\"\u003e\", \"\\t\u003cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"\u003e\", \"\\t\u003ctitle\u003eDocument\u003c/title\u003e\", \"\\t\u003c!-- CSS --\u003e\", \"\\t\u003clink rel=\\\"stylesheet\\\" type=\\\"text\\\\css\\\" href=\\\"\\\"\u003e\", \"\\t\u003cstyle\u003e\", \"\", \"\\t\u003c/style\u003e\", \"\u003c/head\u003e\", \"\", \"\u003cbody\u003e\", \"\\t\u003c!-- JS --\u003e\", \"\\t\u003cscript\u003e\", \"\",\t\"\\t\u003c/script\u003e\", \"\u003c/body\u003e\", \"\", \"\u003c/html\u003e\" ], \"description\": \"create HTML5 templete\" } }   ","description":"","tags":null,"title":"VS Code自定义快捷模块","uri":"/base/20.12.8/"},{"categories":null,"content":"仅此记录过程，供日后复用。    多主机共享ssh Public/Private Key   原本地仓库的id_rsa和id_rsa.pub打包传输到其他主机  生成 ssh key 命令：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ssh-keygen -t -rsa -C \"example@example.com\" ssh -v git@github.com // No more authentication methods to try. // Permission denied (publickey). ssh -agent -s // SSH_AUTH_SOCK=/tmp/ssh-GTpABX1a05qH/agent.404; export SSH_AUTH_SOCK; //SSH_AGENT_PID=13144; export SSH_AGENT_PID; // echo Agent pid 13144; ssh-add ~/.ssh/id_rsa // 若 Could not open a connection to your authentication agent. eval `ssh-agent -s` ssh-add ~/.ssh/id_rsa     github settings 将id_rsa.pub录入\n  验证\n  ssh -T git@github.com  设置用户信息  $ git config --global user.name \"Margin\" $ git config --global user.email \"example@example.com\"   git clone address    git remote add origin address    git pull origin master    git push      Errors  The following untracked working tree files would be overwritten by merge:  reason: 是由于一些untracked working tree files引起的问题。所以只要解决了这些untracked的文件就能解决这个问题。 Answer: $ git clean -d -fx Explanation: git clean 参数  -n 显示要删除的文件和目录 -x 删除忽略文件已经对git来说不识别的文件 -d 删除未被添加到git的路径中的文件 -f 强制运行     $ git clean -n $ git clean -df $ git clean -f       ","description":"","tags":null,"title":"Github 远端仓库download不同本地","uri":"/base/20.11.20/"},{"categories":null,"content":" - WebPack 前端工程化 WebPack   前端工程化  模块化  ES6 Module server NodeJS CommonJS 浏览器 Require.js AMD   组件化 规范化 自动化(构建，部署，测试)  WebPack  功能  代码转换 文件优化 代码分割 模块合并 自动刷新 自动发布   Install 1 2 3 4 5  npm init -y // 初始化package.json npm install -g webpack webpack-cli // 全局安装 npm install --save-dev webpack webpack-cli// 项目目录安装    entry module.exports = { entry: './path/to/my/entry/file.js'};   ","description":"","tags":null,"title":"Webpack","uri":"/web/webpack/"},{"categories":null,"content":" 1. Introduction 2. Base Item  1. Introduction  2. Base Item ","description":"","tags":null,"title":"React Summary","uri":"/web/reactsummary/"},{"categories":null,"content":"Content  Canvas api 时钟 图片压缩 eCharts   Canvas api  一像素问题  线条模糊不清，宽度更宽 Canvas中的line把中线与像素的起点对齐了，而不是像素的中间点。 translate(0.5, 0.5)   api   时钟  时钟   图片压缩  图片压缩   eCharts  …  ","description":"","tags":null,"title":"可视化 Canvas eCharts","uri":"/web/canvas/"},{"categories":null,"content":"Content  DOM相关 数组   DOM相关  DOM document object model 文档对象模型  获取DOM元素 1 2 3  document.getElementById([ID]) document.body document.getElementsByTagName([标签名])        数组  arr.length-1 最后一项的索引  delete arr[0]; // delete length不变   增删改  push arr[arr.length] = x; 数组末尾追加新项 pop arr.length–; //删除最后一项 shift unshift splice   查找拼接  slice concat   toString  toString join   验证包含  indexOf / lastIndexOf includes   排序  reverse sort   迭代  forEach map    ","description":"","tags":null,"title":"JavaScript 复习（三）","uri":"/web/js-items28-/"},{"categories":null,"content":"Content  前后端分离开发中的AJAX和HTTP  AJAX基础 AXIOS     AJAX基础  AJAX解决网页异步刷新  同步刷新 异步刷新  浏览器可以从服务器同时请求多项内容； 浏览器请求返回的速度会快得多； 只有页面中真正改变的部分得到更新； 能够减少服务器数据流量； 用户可以在页面更新的同时继续工作； 有些改变无须与服务器往返通信就可以处理。     XML / JSON  AJAX实例 GET/POST AJAX状态  xhr.readyState  UNSENT 未发送,默认 OPENED 已打开 执行了OPEN HEADERS_RECEIVED: 服务器已经返回响应头的信息  响应头：Date 返回时的服务器时间 先返回后主体慢慢返回 响应主体：客户端需要的信息   LOADING 主体正在加载返回 DONE 主体信息返回   HTTP网络状态码 - xhr.status  以2开始 200 服务正常返回数据（数据是否为想要的不一定 业务流程：code标识表示业务逻辑上的成功失败） 以3开始 304 读取的是协商缓存的数据 301永久重定向(一般用于域名的转移) 302/307 临时转移/重定向（一般用于服务器的负载均衡） 以4开始 400 请求参数有误 401 无权访问 404 地址错误 403 服务器拒绝执行 [一般都是客户端问题] 以5开头 500 服务器发生未知错误 503 超负荷 [一般是服务器问题]   XHR属性方法     AXIOS  基础见纸笔  ","description":"","tags":null,"title":"JavaScript AJAX相关","uri":"/web/js-items27/"},{"categories":null,"content":"Content  图片延迟加载   图片延迟加载  意义: 性能 一般首次渲染不渲染真实图片，图片部分用一个默认的盒子占位（有默认背景图） 方案1 方案2   ","description":"","tags":null,"title":"JavaScript 插件组件","uri":"/web/js-items25/"},{"categories":null,"content":"Content  事件 事件对象和阻止默认行为 事件的传播机制 mouseover和mouseenter   事件   事件:浏览器赋予元素的默认行为，无论是否绑定方法，某些行为触发，相关事件也会触发。\n 事件参考 鼠标事件  click 点击事件(PC：频繁点击N次，触发N次) 单击事件(移动端：300ms内没有第二次点击，算作单击事件，即300ms延迟) dblclick 双击事件 contextmenu 鼠标右键点击触发 mousedown 鼠标按下 mouseup 鼠标抬起 mousemove 鼠标移动 mouseover 鼠标经过 mouseout 鼠标滑出 mouseenter 鼠标进入 mouseleave 鼠标离开 wheel 滚轮滚动   键盘事件  keydown 键盘按下 keyup 键盘抬起 keypress 长按（除Fn shift Capslock）   触屏事件  [touch event 单手指]  touchstart 手指按下 touchmove 手指移动 touchend 手指松开 touchcancel 意外取消   [gesture event 多手指]   网络事件  online offline   表单事件  focus 获取焦点 blur 失去焦点 submit 表单提交（表单元素都包含在form中，并且点击的按钮是submit） reset 表单重置（表单元素都包含在form中，并且点击的按钮是reset） select 下拉框内容选中 change 内容改变 input (移动端常用) 监控文本框内容随着输入改变而触发   资源事件  load 加载成功(window.onload/ img.onload) error 加载失败 beforeunload 资源卸载之前(window.beforeunload 页面关闭之前触发) …   CSS3动画事件  transitionend transition动画结束 transitionstart 开始 transitioncancel 取消 transitionrun 运行中   视图事件  resize 元素（浏览器）大小改变 scroll滚动条滚动   剪贴板 拖放事件 媒体事件 。。。    事件绑定：元素默认的事件行为绑定方法，行为触发，执行方法\n DOM0  语法：[元素].on[事件] = [函数]  document.body.onclick = function(){};   移除：赋值为null或其他非函数值  document.body.onclick = null;   原理：  每个DOM元素对象的私有属性上有\"onXXX\"的私有属性，对其赋值， 若为undefined没有私有属性不能绑定 只能给当前元素的某个事件行为绑定一个方法，后来者覆盖 性能高     DOM2  语法: [元素].addEventListener([事件],[方法],[捕获/冒泡阶段])  document.body.addEventListener('click',fn1,false);   移除：[元素].removeEventListener([事件],[方法],[捕获/冒泡阶段])  document.body.removeEventListener('click',fn1,false);   原理：  每个DOM元素都会基于__proto__，查找到EvnetTarget.prototype上的addEventListener / removeEventListener， 基于这些方法实现绑定和移除，采用事件池机制 DOM2绑定一般不用匿名函数 凡是浏览器提供的事件行为，都可以基于这种模式完成绑定移除(例：window.onDomContentLoaded) 可以给当前元素的某个事件类型绑定多个“不同”的方法（进入事件池），事件行为触发，事件池按绑定顺序取出方法执行         事件对象和阻止默认行为 事件对象  给当前元素的某个事件行为绑定方法，当事件行为触发，方法执行时，不仅会把方法执行，而且会给方法默认传递一个实参，这个实参即事件对象 存储当前事件操作及触发的相关信息(浏览器本身记录，记录当前这次操作的信息，和所在函数无关) MouseEvent  clientX/clientY 鼠标触发点距当前窗口左上角的X/Y轴坐标 pageX/pageY 鼠标触发点距body的X/Y轴坐标 type 事件类型 target/srcElement 获取当前事件源（当前触发的元素） path 传播路径 ev.preventDefault() / ev.returnValue=false 阻止默认行为 ev.stopPorpagation() / ev.cancelBubble=true 阻止冒泡传播   KeyboardEvent  key 存储按键名字 which/keyCode 获取按键的键盘码  方向键 37-40 左上右下 Space 32 BackSpace 8 Del 46 Enter 13 Shift 16 Ctrl 17 Alt 18   altKey (组合按键) ctrlKey shiftKey   TouchEvent  changedTouches(常用) 手指离开存储最后一次 targetTouches touches 手指离开没有信息 =\u003e TouchList ev.changedTouches[0] 第一个手指的信息     阻止默认行为  默认行为：浏览器赋予元素默认的行为操作  鼠标右键菜单 a标签跳转 记录输入记录   ev.preventDefault() 禁用  1 2 3 4 5 6 7 8 9 10 11 12  // 禁用右键菜单 window.oncontextmenu = function(ev){ ev.preventDefault(); } // a标签跳转 // 1. href=\"javascript:;\" // 2.  link.onclick = function (ev){ ev.preventDefault(); // return false;  }      事件的传播机制 事件的传播机制  阶段一：捕获阶段 CAPTURING_PHASE  window向下逐级查找事件源 为冒泡阶段提供路径 =\u003e ev.path   阶段二：目标阶段 AT_TARGET  触发事件源的事件行为   阶段三：冒泡阶段 BUBBLING_PHASE  按路径，不仅触发当前事件源行为，从内到外，祖先元素的相关事件行为也触发（绑定方法也会执行）   DOM0在目标阶段/冒泡阶段触发,DOM2可以在捕获阶段触发 ev.stopPorpagation() / ev.cancelBubble=true 阻止冒泡传播  ev.stopPropagation ? ev.stopPorpagation() : ev.cancelBubble=true 事件委托/事件代理 ：利用冒泡传播机制，把一个容器A中所有后代元素的某个事件行为E触发要做的操作委托给A的事件行为E，只要触发A中任何元素的E行为，都会传播到A上，把给A绑定的方法执行。基于事件源不同做不同处理。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 点击事件行为存在冒泡传播机制，都会传播BODY上，触发body的click。  // 根据target/srcElement  //  // 性能高  // 操作动态绑定的元素  // 某些需求必须基于此完成 document.body.onclick = function(ev) { let target = ev.target, targetClass = target.className; if(targetClass===\"inner\"){ console.log('INNER'); return; } if(targetClass===\"box\"){ console.log('BOX'); return; } };          mouseover和mouseenter  over和out  从父到子：出父入子（出父不正常） 从子到父：出子入父（入父不正常）   enter和leave  默认阻止了事件冒泡传播    ","description":"","tags":null,"title":"JavaScript 事件绑定相关","uri":"/web/js-items24/"},{"categories":null,"content":"Content  Iterator   Iterator   Iterator是一种机制，遍历各种不同的数据，依次处理成员\n next方法遍历 每次遍历返回一个对象 { done:false, value: xxx}  done：记录是否完成 value：当前遍历的结果      拥有Symbol.iterator，基于for of可遍历\n 对象默认不具备 数组 部分类数组 arguments/ Nodelist/ HTMLCollection… String Set Map generator object …(展开运算符)    实例\n  生成器对象 generator function返回\n  1 2 3 4 5 6 7 8 9 10 11 12  function* func(){ } let iterator = func(); // iterator.__proto__ === func.prototype (Generator) console.log(iterator instanceof func) //=\u003e true; new func(); //Error func is not a constructor  // GeneratorFunction  // + next  // + return  // + throw   ","description":"","tags":null,"title":"JavaScript Iterator","uri":"/web/js-items22/"},{"categories":null,"content":"Content  单例设计模式 Promise 工厂设计模式 发布订阅设计模式   单例设计模式  Promise  工厂设计模式  发布订阅设计模式   观察者模式:level up！\n  发布一个计划，并向计划中订阅一个个方法\n  当触发某个事件或到达某个阶段，通知计划中订阅的方法，按顺序依次执行\n  第一版: 不支持自定义事件，且一个页面只有一个事件池 [单例设计模式]\n  第二版: 支持自定义事件，一个页面只有一个事件池\n  第三版: 多个事件池，事件池独立，也有共同方法 on/off/fire\n  ","description":"","tags":null,"title":"JavaScript 设计模式","uri":"/web/js-items23/"},{"categories":null,"content":"Content  同步异步编程和事件循环   同步异步编程和事件循环  进程和线程  1个进程包含多个线程 进程：程序（一个页面） 线程：一个线程处理一个任务 浏览器多线程：  HTTP网络线程：资源文件加载 GUI渲染线程：页面自上而下渲染，绘制页面 JS渲染线程：用于渲染JS代码   JS单线程：浏览器只开辟一个线程渲染JS，JS本质都是同步的。 JS异步：基于多线程结合EventLoop事件循环，构建异步效果。  定时器:设置定时器是同步的过程，而间隔[Interval]后触发绑定方法执行是异步的     ECstack（栈内存）  代码执行”JS渲染线程“自上而下解析执行，即【主线程】。   Event Queue 事件队列 【等待任务队列】   浏览器加载页面产生，存储待执行的任务，优先级队列\n 微任务队列：（先找）如果微任务队列没有，则在去宏任务队列中查找 宏任务队列：一般按照谁先到达执行条件    代码执行过程中，只要创建一个异步的任务，则会进入EventQueue\n 任务放置完成，不需要等待，主线程继续向下渲染同步的代码 定时器或者事件绑定等创建的异步任务，放置到事件队列，浏览器开辟新线程 =\u003e 监听线程：监听定时器是否到达指定时间 同步任务执行完，主线程空闲，才会看EQ中的等待任务，依次拿出来放置到栈内存，让主线程执行，此任务执行完，主线程再次空闲，再去EQ中查找，即为EventLoop事件循环机制.     js渲染线程  词法分析 自上而下的代码分析为一个个任务，放在宏任务队列，词法分析完成，再执行。   异步任务  宏任务  定时器 事件绑定 AJAX/FETCH等创建的网络请求   微任务  Promise:then/resolve(reject)通知注册的onfulfilled/onrejected方法执行 async/await  async：让一个函数返回Promise实例，默认成功，除非本身就是返回一个Promise实例，结果则以返回实例为主 await:  函数中如果需要使用await，则所在的函数必须基于async修饰 await可以使异步的编程模拟出同步的效果   await后面一般会放置一个Promise实例（其他正常值也是可以的） 等待Promise状态为成功后，获取成功的结果，并且执行函数体中await下面的代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  async function fn() { // 先执行handel，返回一个Promise实例  // + 接下来等待，等待Promise实例变成成功态「再此期间，函数体中await下面代码都不会执行」  // + 当状态变为成功，把成功的结果给result，继续执行下面代码  let result = await handle(); console.log(result); //=\u003e1S后输出'OK'  // 虽然await后面放置的是一个10,肯定算是成功的，但是await下面代码也不是立即执行的，也需要等，等待同步任务执行完  // =\u003e await本身是异步的(await下面的代码，需要等到await后面的Promise实例「不是实例也会当做实例来处理」变为成功，才会执行后面的代码)，模拟出来一个类似于同步的效果  let n = await 10; console.log(n); //=\u003e10  // 如果await后面的Promise实例是失败的，则不再处理之前存放的微任务（也就是下面的代码）：因为没处理失败，浏览器抛出异常 Uncaught (in promise) NO =\u003e用try catch 解决  try { let m = await Promise.reject('NO'); console.log(m); } catch (err) { } } fn();             -实例\n","description":"","tags":null,"title":"JavaScript 同步异步编程和事件循环","uri":"/web/js-items21/"},{"categories":null,"content":"Content  像素相关 layout viewport与visual viewport viewport缩放适配 媒体查询@media vw弹性适配 动态rem适配 弹性flex适配   像素相关  设备像素（像素分辨率）  设备能控制显示的最小单位，常说的1920×1080像素分辨率就是用的设备像素单位.   设备独立像素(dips)  与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，包含越多的物理像素越清晰 window.screen.width|height   CSS像素  指的是我们在样式代码中使用到的逻辑像素，是一个抽象概念 window.innerWidth|Height 含滚动条 document.documentElement.clientWidth/Height Layout Viewport的尺寸（Layout Viewport是\u003chtml\u003e元素的父容器） 不包含滚动条 document.documentElement.offsetWidth/Height html元素的尺寸 window.pageX/YOffset visual viewport对于layout viewport的偏移值   关系  PC端 —— 1个设备独立像素 = 1个设备像素 （在100%，未缩放的情况下，如果缩放到200%可以说1个设备独立像素 = 2个设备像素） 移动端 —— 根据设备不同有很大的差异，根据 ppi 不同我们可以得到不同的换算关系，标准屏幕（160ppi）下 1个设备独立像素 = 1个设备像素   devicePixelRaio(DPR)  window.devicePixelRaio DPR = 设备像素/设备独立像素   设计  iphone5 320*568 DPR 2.0 尺寸640*1136 iphone6 375*667 DPR 2.0 尺寸750*1334 iphone6 414*736 DPR 3.0 尺寸1242*2208     layout viewport与visual viewport  layout viewport用css像素来衡量尺寸，在缩放、调整浏览器窗口的时候不会改变。缩放、调整浏览器窗口改变的只是visual viewport。 在桌面浏览器中，缩放为100%的时候，Layout Viewport宽度等于内容窗口的宽度。但是在移动端，缩放为100%的时候，Layout Viewport不一定等于内容窗口的大小（无响应式设计的需要滑动看）。  viewport缩放适配 1  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scaleable=0\"\u003e    媒体查询@media  手机 + pc 结构写在一套html里 1.@media 2.媒介 screen|TV|print 3.连接符 and not only 4.判断条件(max/min-width/height) 5.{CSS代码块} @media(orientation:portrait|landscape)  1 2 3 4  @media screen and (max-width:480px) { .header {display:none;} .touchHeader {display:none;} }    vw弹性适配 动态rem适配  单位  pc: px % em  1em = 16px (父容器html)  首行缩进 p {text-indent:2em;} logo .logo {text-indent:-9999em;}     手机: rem vw vh vmin vmax  1rem = 16px (根root)  1rem = 100px   viewport  vw 1/100 * 视口宽度 vh 1/100 * 视口高度 vmin vmax     换算   我们假设pad的设计稿是以1920px为标准的。那么： 100vw = 1920px 1vw = 19.2px 我们想要： 1rem = 100px 那么: 100px = 100vw / 19.2 = 1rem 所以： 1rem = 5.208vw。 这时候，我们只要给html的根元素设置： font-size: 5.208vw即可。\n  同理的，手机端我们假设设计稿是以750px为标准的，那么: 100vw = 750px 1vw = 7.5px 我们想要： 1rem = 100px 那么： 100px = 100vw / 7.5 = 1rem 那么： 1rem = 13.33vw\n       弹性flex适配  flex容器  阮一峰flex flex-direction:row|vertical(旧:box-orient:horizontal|vertical(多行文本省略号))  多行文本省略号   flex-wrap:wrap|wrap-reverse 自动折行 flex-flow 上两项复合 justify-content align-items align-content   item项目  order: 0 排列顺序 flex-grow: flex-shrink: flex-basis    ","description":"","tags":null,"title":"CSS3 移动端响应式","uri":"/web/css9/"},{"categories":null,"content":"Content  CSS布局模型 BFC IFC font-size、line-height、vertical-align   CSS布局模型   flow\n inline(默认间距去除：父容器:font-size:0;) img的默认间距    float\n  在非IE浏览器下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。    子元素浮动 父元素高度塌陷(height:0)  手动添加height 缺点：高度定死 overflow:hidden 缺点:溢出隐藏 - 下拉框  原理：BFC 规则： 计算BFC高度，浮动子元素也参与   clear:left/right/both - 块的特点 + clear:both + 空内容 - 缺点：无意义标签 优化第三方案 1 2 3 4 5 6 7 8 9 10 11  .clearfix::after { content :''; display:block; clear:both; width:0; height:0; font-size:0; overflow:hidden; visibility:hidden; }    可公用        layer\n 相同点：position + 方位 + z-index 不同点：  参照物  relative :自身 absolute ：父元素 脱离文档流 fixed ： 脱离文档流         BFC    \u003e BFC的生成:满足条件： \u003e 1.根元素 \u003e 2.float不为none \u003e 3.overflow不为visible(auto scroll hidden) \u003e 4.display为inline-block、table-cell、table-caption \u003e 5.position为absolute或fixed \u003e \u003e BFC的约束规则： \u003e 1.内部的Box会垂直方向接连放置 \u003e 2.margin塌陷 \u003e 3.每个元素的margin-left与包含块的border-left相接触(左向右)，浮动元素也是如此 \u003e 4.BFC区域不与float元素区域重叠 \u003e 5.计算BFC高度，浮动子元素也参与 \u003e 6.BFC就是页面上的隔离的独立容器，容器里的子元素不影响外面，反之亦然 \u003e \u003e float+margin:两列布局 三列布局   IFC   形成条件： 块级元素中仅含内联元素 布局规则： 1. 子元素水平方向横向排列，并且垂直方向起点为元素顶部 2. 子元素只计算横向样式空间[padding,border,margin] 3. 垂直方向，子元素以不同方式对齐 4. 行框(line box)宽度由包含块和其中浮动决定 5. line box两边紧贴包含块 float优先排列 6. line box高度由CSS行高计算规则缺点，同个IFC的多个line box可能高度不同 7. inline-level boxes总宽度低于line box，水平渲染规则由text-align决定 8. inline box 超过父元素宽度 被分割成多个boxex，分布在多个line box。子元素未设置强制换行时，inline box将不可被分割，溢出父元素。    font-size、line-height、vertical-align  font-size  body 62.5% = 10px   line-height  不定尺寸或多行文字垂直居中  主体元素inline-block 0宽度100%高度辅助元素 vertical-align:middle; (font-size:0)   img下间隙  vertical-align: top img{display: block;} font-size: 0 外套一个div line-height足够小   line-height决定一个内联元素的真实占位(真实占行高度)   vertical-align  ","description":"","tags":null,"title":"CSS3 工作原理性能优化","uri":"/web/css10/"},{"categories":null,"content":"Content  ES6的class创建类   ES6的class创建类  ES6的class创建类  ","description":"","tags":null,"title":"JavaScript ES6的class创建类","uri":"/web/js-items20/"},{"categories":null,"content":"Content  Promises/A+源码   Promises/A+源码  Promises/A+ CSS_JS_Repos/JS/PromiseAPLUS.js  ","description":"","tags":null,"title":"JavaScript Promises/A+源码","uri":"/web/js-items19/"},{"categories":null,"content":"Content  img\u0026HTML\u003carea\u003e background-icon icon-Sprites iconfont-HTML iconfont-CSS SVG-CSS CSS绘制icon   img\u0026HTML\u003carea\u003e  img默认下间距消除  reset.min.css img{display:block;} img{vertical-align:top|middle|…}   \u003carea\u003e   background-icon  icon-Sprites  减少http请求，提高性能   iconfont-HTML  unicode编码 \u003cdiv class=“iconfont”\u003e \u0026#xe900;\u003c/div\u003e   iconfont-CSS  icomoon 导入style.css \u003cdiv\\ class=“iconfont icon-home”\u003e\u003c/div\u003e iconfont Symbol   SVG-CSS  CSS-icon cssicon ","description":"","tags":null,"title":"CSS3 icon","uri":"/web/css7/"},{"categories":null,"content":"Content  定位常见值及原理 position fixed和sticky 层叠上下文和层叠顺序 层叠上下文形成条件 固定定位特殊性 层叠上下文对z-index的影响   定位常见值及原理  position属性  static(default)  默认定位，不产生重叠，top，right，bottom，left，z-index属性无效   relative  相对于默认位置偏移，即定位基点为元素默认位置，必须搭配四方位一起使用 使用情形：  1.使方位和z-index生效 2.作为absolute的参照物     fixed  相对于viewport偏移，搭配四方位 脱离文档流 使用情形：  1.滚动条滚动固定不动     absolute  相对于上级（父元素）偏移 父元素如果是static，变为相对于html 脱离文档流   sticky(2017)  动态固定   小结  文档流：  脱离：absolute + fixed 不脱离：relative   参照物：  absolute - 父 fixed - 窗口 relative - 自身   相同点： 方位 + z-index 提高层级       position fixed和sticky  fixed  始终固定 方位设置，不显式设置也会生效 脱离文档流   sticky  不一定始终固定 方位设置临界值才固定，至少显式设置一个方位 不脱离文档流 元素的定位参考对象距离其最近的overflow属性值为visible的具有滚动条的祖先元素，如果是以 body或者body的⽗辈元素为考，那么定位参考对象是窗⼝。     层叠上下文和层叠顺序  层叠上下文 层叠等级  同一个层叠上下文，它描述定义的是该层叠上下⽂中的层叠上下⽂元素在Z轴上的上下顺序。   层叠顺序  正z \u003e z-index:auto | 0 \u003e inline/inline-block \u003e float \u003e block \u003e 负z \u003e 层叠上下文 background/border 内容 \u003e 布局 \u003e 装饰     层叠上下文形成条件  层叠上下文  \u003chtml\u003e position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素； position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素; flex (flexbox) 容器的⼦元素，且 z-index 值不为 auto； grid (grid) 容器的⼦元素，且 z-index 值不为 auto； opacity 属性值⼩于 1 的元素； mix-blend-mode 属性值不为 normal 的元素； 不为none：  transform filter perspective clip-path mask / mask-image / mask-border   isolation : isolate -webkit-overflow-scrolling:touch will-change   条件小结  1.html 2.position(非static) 3.CSS3   小结  层叠上下⽂可以包含在其他层叠上下⽂中，并且⼀起创建⼀个层叠上下⽂的层级。 每个层叠上下⽂都完全独⽴于它的兄弟元素：当处理层叠时只考虑⼦元素。 每个层叠上下⽂都是⾃包含的：当⼀个元素的内容发⽣层叠后，该元素将被作为整体在⽗级层叠上下 ⽂中按顺序进⾏层叠。     固定定位特殊性  单纯是绝对/相对定位元素是⽆法创建⼀个层叠上下⽂的，需要同时满⾜ z-index 值不为 auto 的条 件。然⽽，固定定位元素就不需要满⾜这个条件. 固定定位元素⽆需满⾜ z-index 值不为 auto 的条件就可以创建层叠上下⽂；同样地，设置 z-index: auto 并不能撤销固定定位元素所创建的层叠上下⽂。 正常情况下，固定定位是相对于浏览器视窗（viewport）进⾏定位的，但是当其祖先元素中存在符 合以下任意⼀个条件的元素时，固定定位元素会相对于该元素进⾏定位：  transform不为none; transform-style:preserve-3d; perspective不为none; will-change指定上面任一个;     层叠上下文对z-index的影响  层叠上下⽂（stacking context）并不只是z-index（必须配合position才能⽣效）才能创建，还有 很多其他元素（如：opacity、transform等）也可以创建层叠上下⽂; 在存在层叠上下⽂的情况下，z-index的⼤⼩决定了层叠⽔平（stacking level）， 层叠⽔平的⽐较只有在同⼀级别的DOM节点的层叠上下⽂中才有意义; 在同⼀DOM节点，并且层级⽔平⼀样的情况下，在HTML⽂档中写在后⾯的元素会遮住前⾯的元素   ","description":"","tags":null,"title":"CSS3 定位和层叠上下文原理","uri":"/web/css6/"},{"categories":null,"content":"Content  Promise   Promise  ES6新增的一个内置类，承诺/约定模式，基于这种模式可以有效地处理异步  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  //“AJAX串行\"  let data = null; //基于JQ-\u003eAJAX异步从服务器获取数据  $.ajax({ url:'api/1.json', method:'GET', dataType:'json', success:function(result) { data = result; } }); // 回调地狱  $.ajax({ url:'api/1.json', method:'GET', dataType:'json', success:function(result) { $.ajax({ url:'api/2.json', method:'GET', dataType:'json', success:function(result) { $.ajax({ url:'api/3.json', method:'GET', dataType:'json', success:function(result) { // ...  } }); } }); } }); // Promise  const api1 = () =\u003e { return new Promise(resolve =\u003e { $.ajax({ url:'api/1.json', method:'GET', dataType:'json', success:function(result) { resolve(result); } }); }); }; const api2 = () =\u003e { return new Promise(resolve =\u003e { $.ajax({ url:'api/2.json', method:'GET', dataType:'json', success:function(result) { resolve(result); } }); }); }; const api3 = () =\u003e { return new Promise(resolve =\u003e { $.ajax({ url:'api/3.json', method:'GET', dataType:'json', success:function(result) { resolve(result); } }); }); }; api1().then(result =\u003e { return api2(); }).then(result =\u003e { return api3(); }).then(result =\u003e { console.log('OK'); }); (async function(){ let result = await api1(); result = await api2(); result = await api3(); })();    异步：  ajax请求 事件绑定 定时器 Promise/async/await window.requestAnimationFrame    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203  // new Promise  // 立即执行传递的executor函数  // 在executor函数中一般用来管控一个异步的操作  // 传递给executor函数两个函数参数  // 创造Promise实例  // [[PromiseState]] ：3种状态 \"pending\" \"fulfilled/resolved\" \"rejected\"  // [[PromiseResult]] :默认undefined，存储成功的结果或失败的原因  // p1.__proto__ -\u003e Promise.prototype : then / catch / finally  //执行resolve控制实例的状态变为成功，传递的值是成功的结果  // [[PromiseState]] : 'fulfilled'  // [[PromiseResult]] :100  // resolve(100);  //执行reject控制实例的状态变为失败  // [[PromiseState]] : 'rejected'  // [[PromiseResult]] :0  // reject(0);  //一旦状态从pending改变，无法再次改变  // 报错 =\u003e rejected  //执行顺序  // 1.new Promise  // 2.executor:一个异步定时器  // 3.p1.then注入2个方法  // ----等待1000ms  // 4.执行定时器回调函数：执行resolve改变promise状态  // 5.通知之前基于then注入的两个方法的第一个执行  let p1 = new Promise(function(resolve, reject){ setTimeout(()=\u003e{ resolve('OK'); },1000); }); p1.then(result =\u003e{ // p1实例的状态修改为fulfilled，通知第一个函数执行，result -\u003e[[PromiseResult]]  }, reason =\u003e { // p1实例的状态修改为rejected，通知第二个函数执行，reason -\u003e[[PromiseResult]]  }); let p1 = new Promise(function(resolve, reject){ console.log(1); // -\u003e(1)  resolve('OK'); // 修改状态和值，  // 并通知基于Then注入的方法执行[问题:.Then还没执行，方法还没注入，不知道该通知谁来执行]  // 此时需要把通知方法执行的操作先保存起来 【放入到等待任务队列】 -\u003e异步操作  console.log(2); // -\u003e(2)  }); p1.then(result =\u003e{ // p1实例的状态修改为fulfilled，通知第一个函数执行，result -\u003e[[PromiseResult]]  console.log(result); //-\u003e(4)  }, reason =\u003e { // p1实例的状态修改为rejected，通知第二个函数执行，reason -\u003e[[PromiseResult]]  console.log(reason); }); console.log(3); // -\u003e(3)  let p1 = new Promise(resolve =\u003e { setTimeout(()=\u003e{ resolve('OK'); // -\u003e 立即修改状态和值 同步  console.log(1); // -\u003e(1) 说明无论是否基于then注入了方法，执行resolve/reject，  // 通知对应注入方法执行的操作是异步操作，不立即执行，排入等待队列，其他处理完再通知对应方法执行  },1000); }); p1.then(result =\u003e { console.log(2); // -\u003e (2)  }); // ============================================== \t// promise实例状态和值  // 1.new Promise  // executor resolve/reject执行控制其状态及值 执行失败控制报错  // 2. .then返回的新实例  // .then注入的两个方法无论哪个执行，只要不报错，新实例的状态即\"fulfilled\"；  // 只要执行报错，新实例的状态就是rejected;且新实例的[[Result]]是方法返回的值  // 但如果方法执行返回的是一个新的promise实例，则此实例最后的成功或者失败，  // 直接决定.then返回实例的成功和失败，得到的结果是一样的。  let p1 = Promise.resolve('OK'); let p2 = p1.then(result =\u003e { console.log('成功-\u003e',result); // 成功 'OK'  return 10; }, reason =\u003e { console.log('失败-\u003e',reason); }); p2.then(result =\u003e { console.log('成功-\u003e',result); // 成功 10  }, reason =\u003e { console.log('失败-\u003e',reason); }); console.log(p2); //promise 新实例 执行.then返回一个全新的promise实例  let p1 = Promise.reject('NO'); let p2 = p1.then(result =\u003e { console.log('成功-\u003e',result); return 10; }, reason =\u003e { console.log('失败-\u003e',reason); //失败 NO  return 20; }); p2.then(result =\u003e { console.log('成功-\u003e',result); // 成功 20  }, reason =\u003e { console.log('失败-\u003e',reason); }); let p1 = Promise.resolve('OK'); let p2 = p1.then(result =\u003e { console.log('成功-\u003e',result); //-\u003e 成功 'OK'  return Promise.reject('NO'); }, reason =\u003e { console.log('失败-\u003e',reason); return 20; }); p2.then(result =\u003e { console.log('成功-\u003e',result); }, reason =\u003e { console.log('失败-\u003e',reason); // -\u003e 失败 'NO'  }); // 对于失败的promise实例，如果没有进行任何的方法处理，则console抛出异常【但不会阻碍其余代码执行】  Promise.reject('NO').then(result =\u003e { console.log('成功-\u003e',result); return 10; }, ()=\u003e{}); // .then注入方法的时候， 如果其中某个方法没有传递， 则会顺延到下一个then中具备相同状态需要执行的函数中  Promise.reject('NO') .then(result =\u003e { console.log('成功-\u003e',result); return 10; }/*,reason=\u003e{ return Promise.reject(reason);}*/) .then(null, reason =\u003e { console.log('失败-\u003e'),reason); // -\u003e 失败 'NO'  }); Promise.resolve('OK') .then(null, reason =\u003e { console.log('失败-\u003e'),reason); }) .then(result =\u003e { console.log('成功-\u003e',result); // -\u003e成功 'OK'  }); // 存放多个成功，最后一个THEN存放失败，无论某一次失败导致promise实例状态是失败的，  // 都会顺延到最后一个失败的处理函数上进行处理  // + then(null,return =\u003e {...}) 用 catch(reason=\u003e{...}) 代替  Promise.reject('NO') .then(result =\u003e { console.log('成功-\u003e',result); return 10; }) .then(result =\u003e{ console.log('成功-\u003e',result); return 20; }) .then(null, reason =\u003e { console.log('失败-\u003e'),reason); }); // 多处理  // Promise.all 等待所有promise实例都成功，整体返回的状态才是成功，只要有一个失败，整体失败  // Promise.race 看谁先处理完，先处理完成的状态就是最后整体的状态  const api1 = () =\u003e { return new Promise(resolve =\u003e { resolve('OK'); } }; const api2 = () =\u003e { return new Promise(resolve =\u003e { resolve('OK'); } }; const api3 = () =\u003e { return new Promise(resolve =\u003e { resolve('OK'); } }; const fn = () =\u003e { return new Promise(resolve =\u003e { setTimeout(() =\u003e { resolve(100); },1000); }); }; const AA = Promise.resolve('AA'); let p = Promise.all([api(), api2(), api3(), AA, fn(), 10]); p.then(result =\u003e{ //都成功，p成功；results存每个promise的结果  console.log('成功-\u003e',result); }) .catch(reason =\u003e{ //只要有一个失败，立即结束，p失败，记录谁失败即原因  console.log('成功-\u003e',reason); }); // ajax并行：同时发送多个异步的ajax请求（三者之间没有依赖关系），但需要所有的异步请求都处理成功，再统一完成任务     ","description":"","tags":null,"title":"JavaScript Promise","uri":"/web/js-items18/"},{"categories":null,"content":"Content  深克隆浅克隆  对象 数组   深比较浅比较合并  深克隆浅克隆  对象   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  // =============================================浅克隆  let obj1 = { name:\"Margin\", course: { c1:'CSS', c2:'JS' } }; // 克隆1：循环遍历 【浅】  let obj2 ={}; keys = [ ...Object.keys(obj1), ...Object.getOwnPropertySymbols(obj1) ]; keys.forEach(key =\u003e{ obj2[key] = obj1[key]; }); // 克隆2：展开运算符 【浅】  let obj2 = { ...obj1 }; // 克隆3：assign 【浅】  // 原理 Object.assign([obj1],[obj2]);  // =\u003e 返回结果仍是obj1堆内存，只不过是把obj2中的键值对和obj1的键值对合在一起  let obj = Object.assign({},obj1); // 克隆4：自定义浅克隆  // function toType ...待补充  function getOwnPropertys(obj){ /*获得所有私有属性，包括Symbol;*/ if (obj == null) return []; return [ ...Object.key(obj), ...Object.getOwnPropertySymbols(obj) ]; } function shallowClone(obj) { // 处理其他  let type = toType(obj); if (/^(number|string|boolean|null|undefined|symbol|bigint)$/ .test(type)) return obj; if (/^function$/.test(type)) { // 返回一个不同的函数，但是最后执行的效果和原始函数一直  return function proxy () { return obj(); }; } if (/^(regexp|date|error)$/.test(type)) return new obj.constructor(obj); // ..只处理数组或对象  let keys = getOwnPropertys(obj), clone = {}; // clone = new obj.constructor;  Array.isArray(obj)?clone = [] : null; for(let i = 0; i \u003c keys.length; i++) { let key = keys[i]; clone[key] = obj[key]; } // keys.forEach(key =\u003e {  //\tclone[key] = obj[key];  // });  return clone; } // =============================================深克隆  // 克隆1：JSON.stringfy / JSON.parse  // 原理：基于JSON.stringfy把原对象（数组）变为字符串，再基于JSON.parse把字符串转化为对象或者数组。  // 问题：1.正则，Math，ArrayBuffer对象 =\u003e 空对象；  // 2.函数/Symbol/undefined属性值的属性 =\u003e 消失；  // 3. BigInt =\u003e 不能处理； 4. Date =\u003e String  let obj2 = JSON.parse(JSON.stringfy(obj1)); // 克隆2：自定义深克隆  function deepClone(obj, cache=new Set()){ // 只有数组和对象再处理深克隆，其余情况同浅克隆；  let type = toType(obj); if (!/^(array|object)$/.test(type)) return shallowClone(obj); // 避免无限递归  if(cache.has(obj)) return obj; cache.add(obj); let keys = getOwnPropertys(obj), clone = {}; type === \"array\" ? clone = [] : null; keys.forEach(key =\u003e { clone[key] = deepClone(obj[key], cache); }); return clone; }      数组   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // =============================================浅克隆  let arr = [10, 20, [30,40]]; // 克隆1：循环 for each [浅]  let arr2 = []; arr1.forEach((item, index) =\u003e { arr2[index] = item; }); arr2 = arr1.map(item =\u003e item); // 克隆2：展开运算符 Object.assign 【浅】  // 克隆3：基于slice/concat 【浅】  let arr2 = arr1.slice(); // =============================================深克隆  // 克隆1:JSON.stringfy / JSON.parse       深比较浅比较合并   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  //默认参数  let defaults = { url:'', method:'Get', headers:{ 'Content-Type':'application\\json' }, params:null, cache:[true] }; // 用户传递参数  let options = { url:'/api/list', headers:{ 'x-token':'xxx' }, params:{ lx: 0, from:'wechat' }, cache:[10] }; // 浅比较合并  Object.assign(defaults, options); // 对象合并  // obj1对象 obj2对象：依次遍历obj2替换obj1  // obj1对象 obj2不是对象：不进行任何处理  // obj1不是对象 ：obj2直接替换obj1  // 检测数据类型..待补充  function merge(obj1,obj2){\tlet isPlain1 = isPlainObject(obj1), isPlain2 = isPlainObject(obj2); if(!isPlain1) return obj2; if(!isPlain2) return obj1; [ ...Object.keys(obj2), ...Object.getOwnPropertySymbols(obj2) ].forEach(key =\u003e{ obj1[key] = merge(obj1[key],obj2[key]); }); }     ","description":"","tags":null,"title":"JavaScript 对象数组深克隆浅克隆\u0026深比较浅比较合并","uri":"/web/js-items17/"},{"categories":null,"content":"Content  伪类和伪元素 布局 实际布局   伪类和伪元素   伪类：\n ⽤于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据⽤户⾏为⽽动态变化的。 伪类存在的意义是为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的 信息。    伪元素：\n ⽤于创建⼀些不在⽂档树中的元素，并为其添加样式。 伪元素可以创建⼀些⽂档语⾔⽆法创建的虚拟元素。    区别：\n 有没有创建⼀个DOM树之外的元素 伪类本质上是为了弥补常规CSS选择器的不⾜，以便获取到更多信息；伪元素本质上是创建了⼀个有内容的虚拟容器； 可以同时使⽤多个伪类，⽽只能同时使⽤⼀个伪元素；     布局  table   display:table\ndispaly:table-cell, 即td\ndisplay:table-row, 即tr\ntable-layout:fixed|auto\n  Float    在非IE浏览器下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 BFC的生成:满足条件： 1.根元素 2.float不为none 3.overflow不为visible 4.display为inline-block、table-cell、table-caption 5.position为absolute或fixed BFC的约束规则： 1.内部的Box会垂直方向接连放置 2.margin塌陷 3.每个元素的margin-left与包含块的border-left相接触(左向右)，浮动元素也是如此 4.BFC区域不与float元素区域重叠 5.计算BFC高度，浮动子元素也参与 6.BFC就是页面上的隔离的独立容器，容器里的子元素不影响外面，反之亦然 float+margin:两列布局 三列布局    inline-block   处理间隙(父元素:font-size:0)\n  Flex   display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */\ndisplay: -moz-box; /* Firefox 17- */\ndisplay: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */\ndisplay: -moz-flex; /* Firefox 18+ */\ndisplay: -ms-flexbox; /* IE 10 */\ndisplay: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */\n  Grid Columns Shapes 盒模型   实际布局  水平居中  文字,块,多个块  1 2 3 4 5  \u003cbody\u003e \u003cdiv id=\"parent\"\u003e \u003cdiv id=\"child\"\u003eMargin\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u003cstyle\u003e /* 方案1 */ #parent{text-align:center;} #child{display:inline-block;} /* 优点：兼容性 */ /* 缺点：子元素文本继承text-align而居中 */ /* 方案2 */ #child{display:table;margin:0 auto;} /*缺点：子元素脱离文档流，margin属性无效 */ /* 方案3 */ #parent{position:relative;} #child{position:absolute;left:50%;margin-left:-[parentWidth]/2;} /* 方案4 */ #parent{position:relative;} #child{position:absolute;left:50%;transform:translateX(-50%)} /*优点: 父元素是否脱离文档流，不影响子元素水平居中*/ /*缺点：兼容性 */ /* 方案5 */ #parent{display:flex; justify-content:center;} \u003c/style\u003e    小结  ⽂本/⾏内元素/⾏内块级元素 .parent{text-align:center} 单个块级元素 .son{width:1000px(定宽)，margin:0 auto} 多个块级元素 .parent{text-align:center} .son{display:inline-block} 使⽤绝对定位: ⼦绝⽗相，top、right、bottom、left的值是相对于⽗元素尺⼨的，然后margin或者transform是相对于⾃身尺⼨的，组合使⽤达到⽔平居中的⽬的; 任意个元素(flex): #parent{display: flex; justify-content: center; }     垂直居中 1 2 3 4 5  \u003cbody\u003e \u003cdiv id=\"parent\"\u003e \u003cdiv id=\"child\"\u003eMargin\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u003cstyle\u003e /* 方案1 */ #parent{;} #child{line-height = [parentHeight];} /* 方案2 */ #parent{display:table-cell;vertical-align:middle;} /*缺点：子元素脱离文档流，margin属性无效 */ /* 方案3 */ #parent{position:relative;} #child{position:absolute;top:50%;margin-top:-[parentWidth]/2;} /* 方案4 */ #parent{display:flex; align-items:center;} /*缺点：子元素脱离文档流，margin属性无效 */ \u003c/style\u003e    小结：  ⽂本/⾏内元素/⾏内块级元素 .parent{height:150px;line-height:150px;} ⾼度等于⾏⾼的值； 图⽚元素: .parent{height:150px;line-height:150px;font-size:0;} .son{vertical-align:middle} 单个块级元素:  使⽤tabel-cell实现: .parent{display:table-cell;vertical-align:middle} 使⽤position实现: ⼦绝⽗相，top、right、bottom、left的值是相对于⽗元素尺⼨的，然后margin或者transform是相对于⾃身尺⼨的，组合使⽤达到垂直居中的⽬的； 利⽤flex实现 .parent{display:flex; align-items: center;}   任意个元素：.parent{display:flex; align-items: center;} 或 .parent{display:flex;} .son{alignself:center;}或者 .parent{display:flex;flex-direction: column;justify-content: center;}     居中布局 两列布局 三列布局1 三列布局2，圣杯布局，双飞翼 等分布局，等高布局，全屏布局 多列布局  columns column-width column-count column-rule-color column-rule-style column-rule-width column-span column-fill column-gap    ","description":"","tags":null,"title":"CSS3 伪类伪元素\u0026布局","uri":"/web/css5/"},{"categories":null,"content":"Content  数据类型检测底层机制  typeof instanceof constructor Object.prototype.toString.call   重写instanceof  数据类型检测底层机制  typeof  返回结果为字符串 typeof typeof xxx =\u003e\"string\" typeof null =\u003e \"object\" 无法细分普通或数组等对象，一律为object   instanceof  检测当前实例是否属于这个类 Array[Symbol.hasInstance](arr) 一般只用于对象的具体细分，认不清正则 不能证明 xxx instaceof Object是true就是普通对象 无法应用到原始值类型检测 改变了prototype的也不能判断   1 2  let obj = {}; arr instance of obj; // error Function.prototype    + Symbol.hasInstance原理 + (\\_\\_proto\\_\\_)是否存在类原型 - ```js arr.__proto__===Array.prototype // =\u003e arr instanceof Array : true ``` - ```js arr.__proto__.__proto__===Object.prototype // =\u003e arr instanceof Object : true ```  constructor  constructor可以被随意更改 支持基本类型值   Object.prototype.toString.call([value])  除Object.prototype.toString不是转换字符串用来检测数据类型，其余都是 返回结果\"[object 对象[Symbol.toStringTag||对象.构造函数(不受自己更改的影响，对内置类有效)||Object]]\"     重写instanceof  重写instanceof  ","description":"","tags":null,"title":"JavaScript 数据类型检测底层机制","uri":"/web/js-items16/"},{"categories":null,"content":" 类数组想用数组中的方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14  let obj = { 0:10, 1:20, length:2 }; // 解法1： 改变this Array.prototype.forEach.call(obj,item=\u003e{console.log(item);}); // 解法2: 改变原型指向 obj.__proto__ = Array.prototype; obj.forEach(item=\u003econsole.log(item)); // 解法3: 需要用的方法作为obj的一个私有属性 obj.each = Array.prototype.forEach; obj.each = (item =\u003e console.log(item));    数据类型检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  /*JQ中数据类型检测源码*/ var class2type = {}; var toString = class2type.toString; var hasOwn = class2type.hasOwnProperty; var fnToString = hasOwn.toString; var ObjectFunctionString = fnToString.call( Object ); var support = {}; var isFunction = function isFunction( obj ) { // Support: Chrome \u003c=57, Firefox \u003c=52  // In some browsers, typeof returns \"function\" for HTML \u003cobject\u003e elements  // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).  // We don't want to classify *any* DOM node as a function.  return typeof obj === \"function\" \u0026\u0026 typeof obj.nodeType !== \"number\"; }; var isWindow = function isWindow(obj) { // window.window === window \treturn obj != null \u0026\u0026 obj === obj.window; }; function toType( obj ) { if ( obj == null ) { return obj + \"\"; } // Support: Android \u003c=2.3 only (functionish RegExp) \treturn typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj; }   ","description":"","tags":null,"title":"JavaScript JQ源码对象相关(待补充)","uri":"/web/js-items15/"},{"categories":null,"content":"原型重定向  内置类原型无法重定向 大量方法扩充  1 2 3 4 5 6 7 8 9 10 11  function Fn(){} Fn.prototype = Object.assign(Fn.prototype,{ say(){}, jump(){}, eat(){} }); //简化编写，统一管理 // 弊端 : constructor丢失 原有的原型方法丢失 // + 手动设置constructor 和方法 // + 新旧原型对象合并    对象数据类型  普通/日期/正则/数组/DOM元素/类数组集合… prototype原型(排除Function.prototype) __proto__(排除Object.prototype.__proto__) … 函数  所有的函数也是\"普通对象\"，具备__proto__，都是Function的实例 Function.prototype 本质是一个匿名空函数 Function.__proto__ === Function.prototype Function.prototype上存在 call/apply/bind… 所有函数都可以找到这三个方法调用执行 Function是对象，他是Object的实例，Object是函数，它是Function的实例 函数都有’name' ‘length’ 箭头函数无prototype，不能 new 箭头函数   new Foo; new Foo();  能否传递实参 优先级 19 20 (obj.xxx 成员访问 20)     创建值  字面量 构造函数  引用类型 上述两种无本质区别 基本类型  字面量创造的是基本数据类型值，是所属类的实例 构造函数方式创造引用数据类型，是所属类的实例      1 2 3 4 5 6 7 8 9 10  let num1 = 10; let num2 = new Number(10); console.log(num1.toFixed(2)); //=\u003e'10.00' 底层：默认先把10转换为对象格式，再调用Number.prototype的方法处理 console.log(num2.toFixed(2)); // =\u003e'10.00' 基于__proto__查找调用 console.log(num1 + 20); // =\u003e 30 直接运算 console.log(num2 + 20); // =\u003e 30 底层：  // + 对象-\u003e数字/字符串  // + 首先调用num2[Symbol.toPrimitive]  // + 没有则调用num2.valueof()  // + 没有则toString/Number   this  事件绑定 函数执行  自执行函数 回调函数 …   构造函数执行(new) 箭头函数中没有自己的this,所用this使用context中的this  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  let obj = { name = 'Margin', age: 24, fn: function(){ // this -\u003e obj  return function (){ // this -\u003e window  console.log(this); }; } }; let f = obj.fn(); f(); let obj = { name = 'Margin', age: 24, fn: function(){ // this -\u003e obj  return () =\u003e { // this -\u003e obj  console.log(this); }; } }; let f = obj.fn(); f(); f.call(100);//操作无效 没有this call/apply操作也是无效的     基于call/apply/bind改变函数this  Function.prototype =\u003e call/apply/bind  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  window.name = 'WINDOW'; let obj ={ name:'Margin', age:24 }; function fn() { console.log(this.name); } fn(); //this-\u003ewindow obj.fn();//error  fn.call(obj); //this-\u003eobj fn先基于__proto__找到Function.prototype.call，call执行时候，fn执行且fn的this变为第一个实参值 fn.call();//this-\u003ewindow 严格模式 undefined fn.call(null);//this-\u003ewindow 严格模式 null [undefined与null相同] //-------- fn.call(obj,10,20); fn.apply(obj,[10,20]);//传递数组参数的一项项     e.g. 获取数组最大值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  let arr = [10, 30, 15, 36, 23]; //排序  arr.sort(function(a,b){ return b - a; }); let max = arr[0]; //假设  let max = arr[0]; for (let i = 1; i \u003c arr.legth;i++) { let item = arr[i]; if (item \u003e max) { max = item; } } //reduce  let max = arr.reduce((result,item) =\u003e { return item \u003e result ? item : result; }); //Math.max  Math.max(10,30,15,36,23); //ES6  let max = Math.max(...arr); //apply的传递特点  let max = Math.max.apply(null,arr); //字符串拼接  let str = 'Math.max(${arr})'; let max = eval(str);     e.g. 类数组集合转换为数组集合  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function sum(...arr){ // arguments :实参集合，类数组，不是Array  let arr = [...arguments]; let arr = Array.from(arguments); let arr = []; for (let i = 0; i\u003carguments.length; i++){ let item = arguments[i]; arr.push(item); } //let arr = [].slice.call(arguments);  return arr.reduce((result, item) =\u003e item + result); } let total = sum(10,20,30,40); //浅克隆 let ary = [10,20,30]; let newAry = ary.slice();//不传递或传递0 //重写slice Array.prototype.slice = function slice() { let arr = []; for(let i = 0; i\u003cthis.length; i++){ let item = this[i]; arr.push(item); } return arr; }; // 如果让内置slice执行，this改为arguments，实现类数组克隆转换为数组 // 1.slice执行 // Array.prototype.slice() // [].slice() // 2.改变this // [].slice.call(arguments)      e.g. 事件触发，定时器时间，执行对应方法改变this，给方法传递实参  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //立即处理 document.body.onclick = fn.call(obj, 10 ,20); setTimeout(fn.call(obj,10,20),1000);//不能实现，call/apply处理，函数立即执行，而不是等事件触发或定时器计时执行  //预处理 [柯里化函数] //先绑定一个匿名函数, 事件触发或达到计时，先匿名函数执行，执行时把需要的fn执行，基于call/apply改变this和参数信息 document.body.onclick = function(ev) { fn.call(obj, 10 , 20, ev); }; setTimeout(function(){ fn.call(obj,10,2j0); },1000); //bind，不立即执行，先处理this和参数 document.body.onclick = fn.bind(obj, 10, 20); setTimeout(fn.bind(obj,10,20),1000);     e.g. call/apply/bind重写  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //call思路： 需要执行的函数fn，和需要改变的this指向obj关联 // obj.xxx = fn let obj = { name:'Margin', age: 24 fn: fn }; function fn(x,y) { console.log(this); return x + y; } // let result = fn.call(obj, 10, 20); let result = obj.fn(10,20); Function.prototype.call = function call(context, ...params) { // this -\u003e fn  //context -\u003e obj 要改变的this  // params-\u003e[10,20] 要传递的实参  context.xxx = this; let result = context.xxx(...params); delete context.xxx; return result; }; // 优化： 临时设置context的属性不能和原始对象的属性冲突 // 优化： context不传递或null，要改的this是window， // 优化： 要保证context是引用类型值  // + number string boolean 可以 new n.constructor(n)  // + symbol bigint 只能 Object(n) Function.prototype.call = function call(context, ...params) { // this -\u003e fn  //context -\u003e obj 要改变的this  // params-\u003e[10,20] 要传递的实参  context == null ? context = window :null; !/^(object|function)$/.test(typeof context) ? context = Object(context): null; let key = Symbol('KEY'), result; context[key] = this; result = context[key](...params); delete context[key]; return result; }; let obj = { name:'Margin', age: 24 }; function fn(x,y) { console.log(this); return x + y; } let result = fn.call(obj, 10, 20);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //原理：闭包 “柯里化” Function.prototype.bind = function bind(context, ...params) { // this -\u003e fn 要执行的函数  // context -\u003e obj 要改的this  // params -\u003e [10,20] 要传的参数  let that = this; return function proxy(...innerArgs) { params = params.concat(args); return that.call(context, ...params); }; }; let obj = { name:'Margin', age: 24 }; function fn(x,y,ev) { console.log(this,ev); return x + y; } document.body.onclick = fn.bind(obj, 10, 20); //document.body.onclick = function (ev) { // fn.call(obj, 10, 20, ev); //};     ","description":"","tags":null,"title":"JavaScript 对象","uri":"/web/js-items14/"},{"categories":null,"content":"原型prototype 原型链__proto__  new相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  function Dog(name) { this.name = name; } Dog.prototype.bark = function () { console.log('wangwang'); } Dog.prototype.sayName = function () { console.log('my name is ' + this.name); } /* let sanmao = new Dog('三毛'); sanmao.sayName(); sanmao.bark(); */ function _new(Ctor,...params) { // ctor-\u003eDog params-\u003e['三毛']  //1.创建一个实例对象  let obj = {}; obj.__proto__ = Ctor.prototype; //__proto__ IE禁止使用  // Object.create([obj]): 创建一个空对象，把[obj]作为当前空对象的__proto__指向  // - [obj]可以是null或一个对象  // - null，则当前空对象不具备__proto__属性，即不属于任何类的实例  // let obj = Object.create(Ctor.prototype);  //2.构造函数当作普通函数执行[私有context，作用域链，初始this，形参赋值]  // this-\u003e指向创建的实例对象 基于call方法改变即可  let result = Ctor.call(obj, ...params); //3.观察函数执行的返回值，如果没有返回值或返回基本类型，默认返回实例对象，否则返回自己的返回值  if(/^(object|function)$/.test(typeof result)) return result; return obj; } let sanmao = _new(Dog, '三毛'); sanmao.bark(); sanmao.sayName(); console.log(sanmao instanceof Dog); //兼容版本 Object.create = function (pro) { function Proxy(){} Proxy.prototype = pro; return new Proxy; }; function _new(Ctor) { //获取除第一个以外的实参，数组形式保存  var params = [].slice.call(arguments, 1); var obj = Object.create(Ctor.prototype); //基于apply改变this，也可以把数组中的每一项传递给函数  var result = Ctor.apply(obj, params); if(/^(object|function)$/.test(typeof result)) return result; return obj; } var sanmao = _new(Dog, '三毛'); sanmao.bark(); sanmao.sayName(); console.log(sanmao instanceof Dog);    扩展内置类原型方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //去重后排序 Array.prototype.unique = function unique(){ //this -\u003e arr  let result = new Set(this); result = Array.from(result); return result; }; let arr = [1, 2 ,3, 2, 3, 4, 2, 3, 4, 2, 1, 2, 3, 4, 5, 3, 4]; let result = arr.unique().sort((a,b) =\u003e a-b); function unique(arr) { // ...  let result = new Set(arr); result = Array.from(result); return result; } let arr = [1, 2 ,3, 2, 3, 4, 2, 3, 4, 2, 1, 2, 3, 4, 5, 3, 4]; let result = unique(arr); //let result = arr.sort((a,b) =\u003e a-b); console.log(arr,result);   ","description":"","tags":null,"title":"JavaScript 原型与原型链","uri":"/web/js-items12/"},{"categories":null,"content":"面向对象    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function fun(){ this.a=0; this.b=function(){ alert(this.a); } } fun.prototype={ b:function(){ this.a=20; alert(this.a); }, c:function(){ this.a=30; alert(this.a) } } var my_fun=new fun(); my_fun.b(); my_fun.c();    Answer: 0 30     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function C1(name) { if (name) { this.name = name; } } function C2(name) { this.name = name; } function C3(name) { this.name = name || 'join'; } C1.prototype.name = 'Tom'; C2.prototype.name = 'Tom'; C3.prototype.name = 'Tom'; alert((new C1().name) + (new C2().name) + (new C3().name));    Answer: ‘Tomundefinedjoin’     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function Fn() { let a = 1; this.a = a; } Fn.prototype.say = function () { this.a = 2; } Fn.prototype = new Fn;// 原型重定向 let f1 = new Fn; ​ Fn.prototype.b = function () { this.a = 3; }; console.log(f1.a); console.log(f1.prototype); console.log(f1.b); console.log(f1.hasOwnProperty('b')); console.log('b' in f1); console.log(f1.constructor == Fn);    Answer:  1 undefined [Function] false true true       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function Foo() { getName = function () { console.log(1); }; return this; } Foo.getName = function () { console.log(2); }; Foo.prototype.getName = function () { console.log(3); }; var getName = function () { console.log(4); }; function getName() { console.log(5); } Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName(); new new Foo().getName();    Answer: 2 4 1 1 2 3 3     1 2 3  let n = 10; let m = n.plus(10).minus(5); console.log(m);//=\u003e15（10+10-5）    Answer:  1 2 3 4 5 6 7 8 9 10 11 12  function compute(num){ num = Number(num); return isNaN(num)?0:num; } Number.prototype.plus = function(n){ return this+compute(n); } Number.prototype.minus = function(n){ return this-compute(n); }    补充:  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const check = value =\u003e { value = +value; return isNaN(value) ? 0 : value; }; Number.prototype.plus = function(value){ // this-\u003en [对象数据类型]  value = check(value); return this + value; } Number.prototype.minus = function(value){ // this-\u003en [对象数据类型]  value = check(value); return this - value; }      1 2 3 4 5 6  /* * 编写queryURLParams方法实现如下的效果（至少两种方案） */ let url=\"http://www.baidu.com\"; console.log(url.queryURLParams(\"from\")); //=\u003e\"wx\" console.log(url.queryURLParams(\"_HASH\")); //=\u003e\"video\"    Answer:        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function Modal(x,y){ this.x=x; this.y=y; } Modal.prototype.z=10; Modal.prototype.getX=function(){ console.log(this.x); } Modal.prototype.getY=function(){ console.log(this.y); } Modal.n=200; Modal.setNumber=function(n){ this.n=n; }; let m = new Modal(10,20);    Answer:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Parent { constructor(){ this.z = 10; this.getX = function(){ console.log(this.x); } this.getY = function(){ console.log(this.y); } } } class Modal { constructor(x,y) { this.x = x; this.y = y; } z; getX(){} getY(){} n = 200; setNumber = function (n){ this.n = n; }; } let m = new Modal(10,20); //console.log(m);      1 2 3 4 5 6 7 8 9 10 11 12  let obj = { 2: 3, 3: 4, length: 2, push: Array.prototype.push } obj.push(1); //this-\u003e obj val-\u003e 1 // obj[this.length] = 1; =\u003e obj[2] = 1; // obj.length = 1; obj.push(2); console.log(obj);    Answer: { ‘2’: 1, ‘3’: 2, length: 4, push: Array.prototype.push }     1 2 3 4  var a = ?; if (a == 1 \u0026\u0026 a == 2 \u0026\u0026 a == 3) { console.log('OK'); }    Answer:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 解析: // 解法1：利用对象转换为数字 // 引用数据类型转换为数字 // 1.Symbol.toPrimitive // 2.valueOf // 3.toString var a ={ i:0, [Symbol.toPrimitive] () { return ++this.i; } }; let a=[1,2,3]; a.toString = arr.shift; //解法2：Object.defineProperty劫持数据 var a = 0; var i = 0; Object.defineProperty(window,'a',{ get(){ // 1. console.log('OK');  // 2. return ++i;  } });      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let utils = (function(){ /* * toArray：转换为数组的方法 * @params * 不固定数量，不固定类型 * @return * [Array] 返回的处理后的新数组 */ function toArray(){ //=\u003e实现你的代码（多种办法实现）  } return { toArray }; })(); let ary = utils.toArray(10,20,30); //=\u003e[10,20,30] ary = utils.toArray('A',10,20,30); //=\u003e['A',10,20,30]    Answer:  1 2 3 4 5 6 7 8 9 10 11 12 13 14  let utils = (function(){ function toArray(...args){ // 1.return [].slice.call(arguments)  // 2.return Array.from(args)  // 3.return [...args]  } return { toArray }; })(); let ary = utils.toArray(10,20,30); //=\u003e[10,20,30] ary = utils.toArray('A',10,20,30); //=\u003e['A',10,20,30]      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //=\u003e浅克隆：只复制对象或者数组的第一级内容 //=\u003e深克隆：克隆后数组的每一级都和原始数组没有关联 //那么请说出，浅克隆都怎么去实现，如何实现深度克隆 let obj = { a: 100, b: [10, 20, 30], c: { x: 10 }, d: /^\\d+$/ }; let arr = [10, [100, 200], { x: 10, y: 20 }];    Answer:  1       1 2 3 4 5 6 7  //=\u003eexample：要检测的实例 //=\u003eclassFunc:要检测的类 function instance_of(example, classFunc) { //... } let res = instance_of([12,23],Array); console.log(res); //=\u003etrue    Answer  1 2 3  function instance_of(example, classFunc) { return Object.prototype.toString.call(example)===`[object ${classFunc.name}]` }       1 2 3 4 5 6 7 8 9  //=\u003e编写toType方法，实现数据类型检测 function toType( obj ) { //完成你的代码 } console.log(toType(1)); //=\u003e\"number\" console.log(toType(NaN)); //=\u003e\"number\" console.log(toType([])); //=\u003e\"array\" console.log(toType(/^\\d+$/)); //=\u003e\"regexp\" console.log(toType({})); //=\u003e\"object\"    Answer:  1      1 2 3 4 5 6 7 8 9 10 11 12 13  ~function(){ function change(){ //=\u003e实现你的代码  }; Function.prototype.change=change; }(); let obj = {name:'zhufeng'}; function func(x,y){ this.total=x+y; return this; } let res = func.change(obj,100,200); //res =\u003e {name:'Alibaba',total:300}    Answer:  1      1 2 3 4 5 6 7 8 9 10 11 12 13  ~function(){ //=\u003ebind方法在IE6~8中不兼容，接下来我们自己基于原生JS实现这个方法  function bind(){ }; Function.prototype.bind=bind; }(); var obj = {name:'zhufeng'}; function func(){ console.log(this,arguments); //=\u003e当点击BODY的时候，执行func方法，输出：obj [100,200,MouseEvent事件对象] } document.body.onclick = func.bind(obj,100,200);    Answer:  1      1 2 3 4 5 6 7 8 9 10 11 12 13  var name = 'Margin '; function A(x,y){ var res=x+y; console.log(res,this.name); } function B(x,y){ var res=x-y; console.log(res,this.name); } B.call(A,40,30); B.call.call.call(A,20,10); Function.prototype.call(A,60,50); Function.prototype.call.call.call(A,80,70);    Answer:  1 2 3 4  10,\"A\" NaN undefined NaN undefined   ","description":"","tags":null,"title":"JavaScript 练习（二）","uri":"/web/js-items13/"},{"categories":null,"content":"Chapter 1 ","description":"","tags":null,"title":"Web性能笔记","uri":"/web/web%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"每日一题（一）  下列哪个函数可以把3.4转换成4？  A. Math.round() B. Math.floor() C. Math.ceil() D. Math.int()   运行结果？  true false    1  new String(\"string\") instanceof String    运行结果？  true false    1  3 \u003e 2 \u003e 1 === true    下列哪个属性用于CSS Grid布局？  A. grid-rows B. grid-lines C. grid-template-rows D. grid-gap-row    ","description":"","tags":null,"title":"JavaScript 每日一题（一）","uri":"/web/everyday1/"},{"categories":null,"content":"每日一题（二）  JS的垃圾回收机制  暂空   运行结果？  0 undefined 3 error    1 2  console.log([...[...\"...\"]].length); //[\".\",\".\",\".\"] 外面又把它扩展到一个新数组，长度仍为3    运行结果？  1 undefined    1 2 3 4 5 6 7 8  const obj = { a:1, }; const func = () =\u003e { console.log(this.a); }; func.call(obj); //箭头函数的作用域定义时确定，call无法改变this指向， 箭头函数指向window对象   ","description":"","tags":null,"title":"JavaScript 每日一题（二）","uri":"/web/everyday2/"},{"categories":null,"content":"变量提升  红笔标注思考时间长或存疑错点 1. 1 2 3 4 5 6 7 8 9 10 11 12  console.log(a, b, c); var a = 12, b = 13, c = 14; function fn(a) { console.log(a, b, c); a = 100; c = 200; console.log(a, b, c); } b = fn(10); console.log(a, b, c);     结果:\n undefined,undefined,undefined 10,13,14 100, 13, 200 12, undefined, 200    分析：\n 第一行console.log输出时， 变量提升 var a, b, c;，只声明不定义 第二行console.log是在function fn(a){...}内的，当b=fn(10)执行，此时b,c在全局context已经定义，函数fn中没有私有变量b,c，基于作用域链向上查找，而a是实参传递给形参得到10. 第三行console.log是在function fn(a){...}内的，此时a,c被赋值100，200. 第四行console.log是在b=fn(10)执行后，此时a作为全局context的a，值为12，c在函数fn中赋值c=200;得到200，最后fn没有形成闭包，堆内存被释放, b没有指向，故undefined    2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var i = 0; function A() { var i = 10; function x() { console.log(i); } return x; } var y = A(); y(); function B() { var i = 20; y(); } B();     结果:\n 10 10    分析：\n 第一个10，按照函数底层机制步骤推算。 第二个10，B()的私有变量i为20， y() =\u003e A的x()，x的作用域链使得B的私有变量i没有影响到console.log(i)的输出。(正解：函数执行，上级作用域只和创建时的上级有关)    3. 1 2 3 4 5 6 7 8 9 10 11 12 13  var a=1; var obj ={ name:\"tom\" } function fn(){ var a2 = a; obj2 = obj; // window.obj2 = obj;  a2 =a; obj2.name =\"jack\"; } fn(); console.log(a); console.log(obj);     结果:\n 1 { name:“jack” }    分析：\n 见 JS.let/var/this中带var不带var的区别    4. 1 2 3 4 5 6 7  var a = 1; function fn(a){ console.log(a) var a = 2; function a(){} } fn(a);     结果:\n [Function: a]    分析：\n 按var function的顺序变量提升    5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  console.log(a); var a=12; function fn(){ console.log(a); var a=13; } fn(); console.log(a); ---- console.log(a); var a=12; function fn(){ console.log(a); a=13; } fn(); console.log(a); ----     结果:\n undefined undefined 12 //分割线// undefined 12 13    分析：\n 见 JS.let/var/this中带var不带var的区别    6. 1 2 3 4 5 6 7  var foo='hello'; (function(foo){ console.log(foo); var foo=foo||'world'; console.log(foo); })(foo); console.log(foo);     结果:\n hello hello hello    分析：\n 'hello'||'world'结果为'hello'    7.重中之重，精力有限，暂时似懂非懂，本周五考完试分析过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  { function foo() {} foo = 1; } console.log(foo); ---- { function foo() {} foo = 1; function foo() {} } console.log(foo); ---- { function foo() {} foo = 1; function foo() {} foo = 2; } console.log(foo);     结果:\n [Function:foo] 1 1    分析：\n 代码块提升解析 (2020.9.28添加) 变量提升，当前context出现在非函数和对象的大括号中的function只声明不定义,代码执行时，大括号中出现了 function/let/const/，形成一个全新的块级私有context 代码执行，function X会把之前对function X的操作映射给全局。    8. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var x = 1; function func(x,y=function anonymous1(){x=2}) { x = 3; y(); console.log(x); } func(5); console.log(x); --- var x = 1; function func(x,y=function anonymous1(){x=2}) { var x = 3; y(); console.log(x); } func(5); console.log(x); --- var x = 1; function func(x,y=function anonymous1(){x=2}) { var x = 3; var y = function anonymous1(){x=4}; y(); console.log(x); } func(5); console.log(x);     结果:\n 2 1 3 1 4 1    分析：\n  补充：\n 形参赋值默认值 函数体中声明过变量，function的需要和形参中的一个一致。 满足以上两点触发机制：函数执行不仅形成私有context，而且会把函数当作一个块级私有context。如果块级私有context声明的变量在形参中出现，则也会把私有context中的形参变量赋值给块级context同名的变量一份。 触发后，私有context形参赋值后，接下来进入块级context处理。 如果块级的某个私有变量和当前context中的形参变量的名字一样，给块级context。（let/ const报错）    数据类型和基础知识  红笔标注思考时间长或存疑错点 1. 1 2  let result = 100 + true + 21.2 + null + undefined + \"Tencent\" + [] + null + 9 + false; console.log(result);    结果：  NaNTencentnull9false    2. 1 2  {}+0?alert('ok'):alert('no'); 0+{}?alert('ok'):alert('no');    结果：  no ok    3. 1 2 3 4 5 6 7 8 9 10  let res = Number('12px'); if(res===12){ alert(200); }else if(res===NaN){ alert(NaN); }else if(typeof res==='number'){ alert('number'); }else{ alert('Invalid Number'); }    结果：  number    4. 1 2 3  let arr = [27.2,0,'0013','14px',123]; arr = arr.map(parseInt); console.log(arr);    结果：  27 NaN 1 1 27   分析：  parseInt([value],[radix])    闭包作用域  红笔标注思考时间长或存疑错点 1. 1 2 3 4 5 6 7 8 9 10  var a = 10, b = 11, c = 12; function test(a) { a = 1; var b = 2; c = 3; } test(10); console.log(a, b, c);    结果：  10 ,11 ,3    1. 1 2 3 4 5 6 7 8  var a = 4; function b(x, y, a) { console.log(a); arguments[2] = 10; console.log(a); } a = b(1, 2, 3); console.log(a);    结果：  3 10 undefined    3. 1 2 3 4 5 6 7 8 9 10 11 12  var a = 9; function fn() { a = 0; return function (b) { return b + a++; } } var f = fn(); console.log(f(5)); console.log(fn()(5)); console.log(f(5)); console.log(a);    结果：  5 5 6 2   分析：  错因：先return值再a++   补充   4. 1 2 3 4 5 6  var test = (function (i) { return function () { alert(i *= 2); } })(2); test(5);    结果：  4    5. 1 2 3 4 5 6 7 8 9 10 11  var x = 4; function func() { return function(y) { console.log(y + (--x)); } } var f = func(5); f(6); func(7)(8); f(9); console.log(x);    结果：  9 10 10 1    6. 1 2 3 4 5 6 7 8 9 10 11 12  var x = 5, y = 6; function func() { x += y; func = function (y) { console.log(y + (--x)); }; console.log(x, y); } func(4); func(3); console.log(x, y);    结果：  11 6 13 10 6   分析：  存疑   补充：   7. 1 2 3 4 5 6 7 8 9 10 11  function fun(n, o) { console.log(o); return { fun: function (m) { return fun(m, n); } }; } var c = fun(0).fun(1); c.fun(2); c.fun(3);    结果：  undefined 0 1 1   分析：  存疑    8.  闭包：  函数执行形成私有context，context中的某些内容（一般堆内存地址）被context以外的事物（变量等）占用，则当前context不能被释放。  优点：  保护：保护私有context的私有变量和外界互不影响 保存：context的私有变量和值保存起来   弊端：栈内存太大，影响性能，需合理利用      9.  var 存在变量提升 let 不存在变量提升 全局context var相当于给GO增一个属性，一改随改；let和GO没有关系。 let不允许同context重复声明（不管先前何种方式声明，都不能let再声明），var无所谓。 let产生块级私有context 暂时性死区(typeof)  10. 1 2 3 4 5 6  var b = 10; (function b() { b = 20; console.log(b); })(); console.log(b);    结果：  [Function: b] 10   分析：  b=20存疑   修改代码：  1 2 3 4 5 6  var b = 10; (function b() { let b = 20; console.log(b); })(); console.log(b);   11. 1 2 3 4 5  function fn(a,b){ return function(c){ return a+b+c; } }   12. 1  //暂超出能力范围，因本周五有必修课考试，实难在本周花费精力完成此题目。   this  红笔标注思考时间长或存疑错点（this掌握不行，需再练习） 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var num = 10; var obj = { num: 20 }; obj.fn = (function (num) { this.num = num * 3; num++; return function (n) { this.num += n; num++; console.log(num); } })(obj.num); var fn = obj.fn; fn(5); obj.fn(10); console.log(num, obj.num);    结果：  22 23 65 30    2. 1 2 3 4 5 6 7 8 9 10  let obj = { fn: (function () { return function () { console.log(this); } })() }; obj.fn(); let fn = obj.fn; fn();    结果：  {fn:[Function]} Object [global]{ … }    3. 1 2 3 4 5 6 7 8 9 10 11 12  var fullName = 'language'; var obj = { fullName: 'javascript', prop: { getFullName: function () { return this.fullName; } } }; console.log(obj.prop.getFullName()); var test = obj.prop.getFullName; console.log(test());    结果：  undefined language    4. 1 2 3 4 5 6 7 8 9 10 11 12  var name = 'window'; var Tom = { name: \"Tom\", show: function () { console.log(this.name); }, wait: function () { var fun = this.show; fun(); } }; Tom.wait();    结果：  window    5. 1 2 3 4 5 6 7 8 9 10 11 12  window.val = 1; var json = { val: 10, dbl: function () { this.val *= 2; } } json.dbl(); var dbl = json.dbl; dbl(); json.dbl.call(window); alert(window.val + json.val);    结果：  24    6. 1 2 3 4 5 6 7 8 9 10 11  (function () { var val = 1; var json = { val: 10, dbl: function () { val *= 2; } }; json.dbl(); alert(json.val + val); })();    结果：  12    ","description":"","tags":null,"title":"JavaScript 练习（一）","uri":"/web/js-items6/"},{"categories":null,"content":" 面试题  7. hasPubProperty   技巧  面试题   堆栈内存 \n  闭包三题\n   \n\n 5个怪异行为 \n  所有的类都是函数数据类型,所有的实例都是对象类型[但是有特殊性]\n1 2 3 4 5 6 7 8 9 10 11  console.log(typeof Object); //=\u003e\"function\" console.log(typeof Array); //=\u003e\"function\"  function sum(){} // =\u003e typeof sum ===\"function\" let arr = [] // =\u003e Array实例 -\u003e 数组，对象 let n = 10; let m = new Number(10); m.toFixed(2); // '10.00' n.toFixed(2); // '10.00' 转为new Number(10) n-10; // 0 m-10; // 0 浏览器把对象转成数字     this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var x = 3, obj = {x:5}; obj.fn = (function(){ this.x *= ++x; return function(y){ this.x *= (++x)+y; console.log(x); } })(); var fn = obj.fn; obj.fn(6); fn(4); console.log(obj.x, x); // 13 // 234 // 95 234 // this.x *= (++x)+y; 后面是整体     Hoisting\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 1. fn(); // 5 function fn(){console.log(1);} fn(); // 5 function fn(){console.log(2);} fn(); // 5 var fn = function(){console.log(3);} fn(); // 3 function fn(){console.log(4);} fn(); // 3 function fn(){console.log(5);} fn(); // 3  // 2. var foo = 1; function bar() { if (!foo){ var foo = 10; } console.log(foo); // 10 } bar();     hasPubProperty\n   技巧  不“背书” [场景， low一点] 不要只看问题表面，在有限时间内，精简语言更多表达自己 [引导面试官问一些自己擅长或者精心准备的]   基础/理论 实战 Bigger：看源码，造轮子 非技术类  “闭包” 5分钟   过渡语 抛理论：浏览器渲染执行 堆栈内存 GC垃圾回收机制 保护保存 实战：举1~2个例子 源码 造轮子 总结 谦虚反问  ","description":"","tags":null,"title":"JavaScript 面试题","uri":"/web/js_interview/"},{"categories":null,"content":"  所谓真经,就是能够达到寂空涅盘的究竟法门，可悟不可修，修，为成佛，在求；悟，为明性，在知。修行以行制性。悟道以性施行。觉者由心生律；修者以律制心，有信无证者虽不落恶果，却住因住果住念住心，如是生灭不得涅槃。 佛乃觉性，非人，人人都有觉性不等于觉性就是人。人相可坏，觉性无生无灭，即觉即显，即障即尘蔽，无障不显，了障涅槃。觉行圆满之佛乃佛教人相之佛，圆满即止，即非无量，若佛有量即非阿弥陀佛。佛法无量即觉行无量，无圆无不圆，无满无不满，亦无是名究竟圆满。 佛教以次第分，从精深处说是得道天成的道法，道法如来不可思议，即非文化；从浅义说是异人向善的教义，善恶本有人相我相众生相，即是文化。从众生处说是以贪制贪，以幻制幻的善巧，虽不灭败坏下流，却无碍抚慰灵魂的慈悲。\n Margin\n","description":"","tags":null,"title":"《天道》五台山之论","uri":"/other/20.9.182/"},{"categories":null,"content":"简单叙述一下Github Pages换域名的流程，以供日后使用。\n 域名解析配置  注册域名，实名认证 域名解析：   增加新纪录 记录类型：CNAME 主机记录：@ 记录值:username.github.io\n 部署Github流程  Settings =\u003e GitHub Pages =\u003e Custom domain =\u003e 域名 # 稍等片刻即可通过域名访问GitHub Pages\n  Margin\n","description":"","tags":null,"title":"GitHub Pages绑定个人域名","uri":"/base/20.9.18/"},{"categories":null,"content":"本地运行Meme主题使用正常Hugo流程即可，注意使用__Extended__版本Hugo即可。简单叙述一下部署到Github Pages的流程，以供日后使用。\n 本地安装Hugo（以windows例）  安装扩展版Hugo 检查命令：   hugo version\n  建站命令：   hugo new site blog\n  Meme主题：   ~ $ cd blog ~/blog $ git init ~/blog $ git submodule add –depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme\n  替换config：   ~/blog $ rm config.toml ~/blog $ cp themes/meme/config-examples/zh-cn/config.toml config.toml\n  本地运行:   hugo server -D\n 部署Github流程（以workflow方法）  正常部署hugo的命令：   hugo –theme=meme –baseUrl=“http://username.github.io” –buildDrafts //生成public文件夹 cd public git init git add . git commit -m “info” git remote add origin http://github.com/username/username.github.io git push -u origin master\n  Meme:   推送源码而非public   //在blog下运行 git remote add origin http://github.com/username/username.github.io git push -u origin master\n 新建workflow  ```yml #.github/workflows/build.yml name: build on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: 'Building...' uses: reuixiy/hugo-deploy@v1 env: DEPLOY_REPO:username/username.github.io DEPLOY_BRANCH:build DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }} # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones TZ: Asia/Shanghai # DEPLOY_REPO为仓库 DEPLOY_BRANCH为分支 DEPLOY_KEY为私钥 ```  生成公私钥  公钥(id_rsa.pub) Settings \u003e Deploy keys \u003e Add deploy key 勾选 Allow write access 密钥(id_rsa) Settings \u003e Secrets \u003e New secret Name: DEPLOY_KEY   push git add -A git commit -m \"refactor: use hugo-deploy action\" git push  Action处查看日志，Settings \u003e Options \u003e Github Pages，Source中的Branch选为build，完成即可上线。    Margin\n","description":"","tags":null,"title":"Meme主题部署到GitHub Pages","uri":"/base/20.9.17/"},{"categories":null,"content":"  Resume  h1{color:#375e97;font-size: 2em;font-family: Georgia,'Times New Roman';border-bottom: 1px solid #375e97;} header{border-bottom: 3px solid grey;} h2{border-bottom: 1px dashed grey;} section{border-bottom: 3px solid grey;} body{font-family: Arial, Helvetica, sans-serif;}     Resume    Personal Information   姓名： 邮箱： 年龄： 性别： 电话：    Education Experience   2019-2021: DUT 2015-2019: DUT 2012-2015: 1st Middle School    Working Experience   2019-2021: DUT 2015-2019: DUT 2012-2015: 1st Middle School      ","description":"","tags":null,"title":"Resume Sample","uri":"/web/resume/"},{"categories":null,"content":"  Page Title -- --   Contact Me  邮箱：Jialong_Lv@outlook.com Github：@MarginLon     ","description":"","tags":null,"title":"About","uri":"/about/"}]